[ { "title": "Chapter 3. Dynamic Programming", "url": "/posts/3rd-DP/", "categories": "", "tags": "", "date": "2022-07-05 19:46:00 +0900", "snippet": "📰 다이나믹 프로그래밍(Dynamic Programming) 알고리즘이란? 📰 Dynamic?? 알고리즘이 역동적…?Dynamic Programming. 줄여서 DP라고 부르는 이 알고리즘은 정말 정말 다양한 유형의 문제가 있다. 딱히 뭔가 역동적(Dynamic)하거나 어떤 새로운 Programming의 방식을 가져서 이름 붙여진 것은 아니다.이에 관한 내용은 ↓, TMI 로.다이나믹 프로그래밍(DP): 정의: 동적 계획법이라고도 불리며, 여러 개의 하위 문제를 풀어나가며(저장 o), 그 결과를 이용해 최종 답을 도출하는 알고리즘. 이렇게 보면 Chapter 1. 분할 정복과 어찌보면 비슷한 면이 있다. 하지만 DP만의 특징을 좀 더 살펴보자. 메모리를 조금 더 사용하면서 연산속도를 비약적으로 증가시킨다. Top-Down / Bottom-Up 방식으로 두 가지 방식으로 구분된다.Top-Down / Bottom-Up 방식을 좀 더 자세히 살펴보자. Memoization -&gt; Top-Down 방식 재귀를 이용하여 값을 위에서부터 아래로 계산하기 때문에 하향식(top-down) 방식. cache에 값 기록, 중복 계산을 방지. int fib(int n) { if (n == 0) return 0; if (n == 1) return 1; if (dp[n] != -1) return dp[n]; dp[n] = fib(n - 1) + fib(n - 2); return dp[n]; } ▲ 피보나치 하향식 구현 ▲ Tabulation -&gt; Bottom-up 방식 주로 반복문을 이용하여 값을 아래에서부터 위로 계산하기 때문에 상향식(bottom-up) 방식. 리스트에 값을 기록, 중복 계산을 방지. int fib(int n){ dp[0] = 0; dp[1] = 1; for (int i = 2; i &lt;= n; i++) dp[i] = dp[i - 1] + dp[i - 2];}▲ 피보나치 상향식 구현 ▲ 조건 및 장점: DP 알고리즘이 적용되기 위해 2가지 조건이 성립해야한다. 1. 최적 부분 구조(optimal substructure) 문제에 대한 최종 해결 방법은 부분 문제에 대한 최적 문제 해결 방법으로 구성된다. 즉 작은 부분 문제에 대한 답을 모아 큰 문제를 해결 2. 중복되는 부분 문제(overlapping subproblems) DP는 기본적으로 문제를 나누고 그 문제의 결과 값을 재활용해서 전체 답을 구한다. 그래서 동일한 작은 문제들이 반복하여 나타나는 경우에 적용 가능 DP 적용 방식: 1) DP로 풀 수 있는 문제인지 확인 - 어느 알고리즘이든 이게 어떤 알고리즘인지 단번에 파악하는게 힘들다. 보통 특정 데이터 내 최대화 / 최소화 계산을 하거나 특정 조건 내 데이터를 세야 한다거나 확률 등의 계산의 경우 DP로 풀 수 있는 경우가 많다. 2) 문제의 변수 파악 - DP는 현재 변수에 따라 현재 결과값을 찾고 그것을 저장하여 재사용한다. 즉, 문제 내 변수의 개수와 의미를 파악해야한다. 이것을 state를 결정한다고 한다. - 예를 들어, 피보나치 수열에서 n번째 피보나치 숫자를 구하는 것이므로 n이 변수가 된다. 그 변수가 얼마냐에 따라 결과값이 다르나 그 결과를 재사용한다. 3) 변수 간 관계식 만들기(점화식) - 변수마다의 결과값을 얻으면, 각 변수 결과값끼리에 대해 관계를 만들어야 DP의 의미를 부여할 수 있다. 그러한 관계식을 점화식이라고 부르며 반복/재귀를 통해 문제가 자동으로 해결되도록 구현한다. - ex) 피보나치 수열에서는 $f(n) = f(n-1) + f(n-2)$ 였다. 4) 메모하기(memoization or tabulation) - 변수 간 관계식까지 정상적으로 생성되었다면 변수의 값에 따른 결과를 저장해야 한다. 이 결과 값을 저장할 때는 보통 배열을 쓰며 변수의 개수에 따라 배열의 차원이 1~3차원 등 다양할 수 있다. 5) 기저 상태 파악하기 - 여기까지 진행했으면, 가장 작은 문제의 상태를 알아야 한다. 일단 시작점을 정의해야 점화식을 통해 점점 값을 채워나갈 수 있기에 필요하다. 6) 구현하기 - 위에서 언급했던 방식 중 채택하여 구현한다. 장점: 적용 가능시, 모든 가능성을 고려해 구현하므로 항상 최적의 결과를 얻을 수 있다. 메모리에 값을 저장하며 그 값을 재활용하므로 큰 문제를 빠른 속도로 해결할 수 있다. 단점 및 한계: 다른 방법에 비해 많은 저장 공간을 요구한다. DP 예제1) 1로 만들기 - BOJ 1463 문제: 정수 N에 사용할 수 있는 3가지 연산이 있다. 정수 N이 주어졌을 때, 연산을 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하자. 부가 정보 &amp; 조건 N이 3으로 나누어 떨어지면, 3으로 나눈다. N이 2로 나누어 떨어지면, 2로 나눈다. 1을 뺀다. 이 문제는 왜 DP인가? 왜냐면 모든 정수에 대해 일일이 연산을 계산할 필요가 없이, 하위 값들을 재활용하며 큰 정수까지도 최적해를 빠르게 구할 수 있기 때문이다.1) 테이블 정의 $D[i]$ = 숫자 $i$를 1로 만들기 위해 필요한 연산의 최소 횟수.2) 점화식 세우기어떤 숫자 $n$을 고려할 때, $D[n]$은 어떻게 구할 수 있을까? DP의 특성상 현재 보는 수의 하위값들을 다 알고있다고 가정하자. 연산의 종류에 따라서 총 3가지의 경우의 수가 있다.ex) $n = 18$, $D[n]$ = ?연산의 조건에 의해, 3으로 나누기, 2로 나누기, 1로 빼기가 모두 적용되므로, $D[18] = D[6] + 1, D[18] = D[9] + 1, D[17] + 1$와 같이 나타낼 수 있다. 이 중 최솟값이 $D[n]$의 정의에 부합한다.즉 일반화시키면 $D[n] = min(D[n/3]+1, D[n/2]+1, D[n-1]+1)$이다.3) 초기값 설정$D[1] = 0$ 으로만 설정하면 나머지 정수에 대해서는 연산을 통해 해를 구할 수 있다.왜냐하면 1밑으로는 내려갈 일이 없고, 숫자가 올라가면서 나중 상위 값 계산에 필요한 하위 값들을 채워나가기 때문이다. 접근법 및 구현: 전역 배열을 하나 선언한 후(자동적으로 모든값 0으로 초기화), 초기값 $D[1]=1$을 설정해준다. 단순한 반복문과 조건문으로, 모든 수는 일단 3번째 연산이 가능하므로(1 빼기) 설정한 후, 3과 2로 나눠지는 수 인지 체크하고 나눠지면 기존의 $D[i]$값과 비교하여 min값을 채택한다. 테이블을 채워넣은 후 $D[n]$을 출력한다. #include &lt;bits/stdc++.h&gt;using namespace std;int num[1000001];int main(void){\tios::sync_with_stdio(0);\tcin.tie(0);\t\tint n;\tcin &gt;&gt; n;\tnum[1] = 0; // 초기값\t\tfor(int i=2; i&lt;=n; i++)\t{\t\tnum[i] = num[i-1]+1; // 3번째 연산 적용\t\tif(i%2==0)\t\t\tnum[i] = min(num[i/2]+1, num[i]); // 2번째 연산 가능 여부 확인 및 적용\t\tif(i%3==0)\t\t\tnum[i] = min(num[i/3]+1, num[i]); // 1번째 연산 가능 여부 확인 및 적용\t}\tcout &lt;&lt; num[n];}2) RGB거리 - BOJ 1149 문제: RGB거리에는 집이 N개 있다. 집은 빨강, 초록, 파랑 중 하나의 색으로 칠해야 한다. 각각의 집을 빨강, 초록, 파랑으로 칠하는 비용이 주어졌을 때, 아래 규칙을 만족하면서 모든 집을 칠하는 비용의 최솟값을 구해보자. 부가 정보 &amp; 조건 1번 집의 색은 2번 집의 색과 같지 않아야 한다. N번 집의 색은 N-1번 집의 색과 같지 않아야 한다. i(2 ≤ i ≤ N-1)번 집의 색은 i-1번, i+1번 집의 색과 같지 않아야 한다. 이 문제는 접하면 DP가 아니라 Greedy가 아닌가? 라는 생각이 들 수 있다. 즉 N번째 집을 고려할 때, N-1번째 집과 색깔이 다른 두 집 중 최솟값을 계속 골라나가는 형태로 구현하면 되지않는가? 라는 의문이 든다.이에 대한 반례를 설명하겠다.여기서의 실제 최적해는 26+57+13으로 이어지는 ‘96’이다. 하지만 그리디한 방법으로 접근했을 때, 1번째 집에서 3(최솟값), 2번째 집은 빨강과 파랑만 가능하므로 49, 그 다음 초록과 파랑만 가능하므로 89. 즉 141이라는 해가 나오고, 이는 오답이다.애초에 그리디로는 정해진 조건에 의해 탐색하기에, 모든 경로를 탐색할 수가 없기에, 최적해를 보장할 수 없다. 즉, 내가 첫번째 집을 고른순간 이미 다음 집을 무엇을 고를지 정해지는 셈이고, 운이 좋으면 이 경로들 중 답이 있을수는 있지만 항상 보장하지는 않는다.1) 테이블 정의 $D[i][1]$ = $i$번째 집까지 칠할 때의 최소 비용, 단 $i$번째 집은 빨강. $D[i][2]$ = $i$번째 집까지 칠할 때의 최소 비용, 단 $i$번째 집은 초록. $D[i][3]$ = $i$번째 집까지 칠할 때의 최소 비용, 단 $i$번째 집은 파랑.2) 점화식 세우기DP는 문제 형태의 따라 테이블을 1차원, 2차원, 3차원 등으로 세우는데, 이 문제는 2차원 배열이 사용되었다. 문제 조건에 의해 바로 직전에 칠해진 집과는 동일한 색깔로 칠할 수 없다.ex) $D[i][1]$이 채워지려면, $D[i-1][2], D[i-1][3]$ 중 최솟값을 택한 후, $i$번째 집을 빨강으로 칠하는 값을 더하면 된다. 이를 초록과 파랑에도 적용하면 된다.3) 초기값 설정1번째 집을 각각의 색으로 칠하는 최소 비용은 입력으로 주어진 그 숫자 그대로이기 때문에 이 값들만 초기값으로 세팅해준다. 그 이후로는 가능한 경로들을 고려하며 값이 채워나가진다. 접근법 및 구현: 전역 배열을 하나 선언한 후(자동적으로 모든값 0으로 초기화), 초기값 $D[1][1], D[1][2], D[1][3]$을 설정해준다. $N$번째 집마다 특정 색깔로 칠하는 걸 고려할 땐 이전 집을 그 색깔이 아닌 색으로 칠했을때의 최솟값 선택 후 현재 색깔로 칠하는 값을 더하도록 구현한다. 테이블을 채워넣은 후 $min(D[n][1], D[n][2], D[n][3])$을 출력한다. #include &lt;bits/stdc++.h&gt;using namespace std;int house[1001][4]; // 각 색깔로 칠하는 입력값int sum[1001][4]; // DP 테이블int main(void){\tios::sync_with_stdio(0);\tcin.tie(0);\t\tint n;\tcin &gt;&gt; n;\tfor(int i=1; i&lt;=n; i++)\t{\t\tfor(int j=1; j&lt;=3; j++)\t\t{\t\t\tcin &gt;&gt; house[i][j]; \t\t}\t}\tfor(int i=1; i&lt;=3; i++)\t{\t\tsum[1][i] = house[1][i]; // 1번째 집 초기값 세팅\t}\tfor(int i=2; i&lt;=n; i++)\t{\t\tsum[i][1] = min(sum[i-1][2], sum[i-1][3])+house[i][1]; // 빨강으로 칠하기\t\tsum[i][2] = min(sum[i-1][1], sum[i-1][3])+house[i][2]; // 초록으로 칠하기\t\tsum[i][3] = min(sum[i-1][1], sum[i-1][2])+house[i][3]; // 파랑으로 칠하기\t}\tcout &lt;&lt; min(min(sum[n][1], sum[n][2]),sum[n][3]);}3) 평범한 배낭 - BOJ 12865 문제: 준서가 여행에 필요하다고 생각하는 N개의 물건이 있다. 각 물건은 무게 W와 가치 V를 가진다. 준서는 최대 K만큼의 무게만을 넣을 수 있는 배낭을 들고 다닌다. 준서가 최대한 즐거운 여행을 하기 위해 배낭에 넣을 수 있는 물건들의 가치의 최댓값을 알려주자. 부가 정보 &amp; 조건 입력으로 주어지는 수는 모두 정수이다. 이 문제는 0-1 Knapsack이라고 불리는 DP의 대표적인 예이다. 즉 각각의 물건이 넣지 않거나(0), 물건을 넣는(1) 두개의 상태로 구분되기에 이렇게 이름이 붙여졌다.1) 테이블 정의 $D[i][w]$ = $1$~$i$번째 물건까지 고려해, 임시 배낭 용량이 $w$일 때의 최대 가치 여기서 말하는 임시 배낭 용량이란, 원래 문제에서 원하는 답이 배낭의 용량이 C라고 할 때, 1부터 C까지 1씩 증가해나가며 그때그때의 현재 용량을 말한다.2) 점화식 세우기이중 반복문을 통해, 물건을 첫번째 물건부터 n번째 물건까지, 각각 1부터 C까지의 용량에 대해 값을 채워나간다.경우의 수 1) 만약 $W$$i$가 $W$를 초과하면, $D[i][w] = D[i-1][w]$ 왜냐하면 $i$번째 물건을 배낭에 담을 수 없기에, $i-1$번째 물건까지 고려했을 때와 동일하다.경우의 수 2) 그렇지 않다면, $D[i][w]$ = $min(D[i-1][w]$, $D[i-1][w-w$$i$])이다. 1번에 해당되지 않는다면 $i$번째 물건을 담을 수 있는 상태이다. 그러나 현재 상태에서 담으면 배낭의 무게는 $w$+w$i$이 되어 기존 무게인 $w$를 초과해 모순이 발생한다. 따라서 $w$에서 w$i$를 빼주어 물건이 들어갈 공간을 마련한다. 그 상태에서 물건 $i$를 배낭에 넣는다고 생각하면 된다.3) 초기값 설정 $D[i][0]$ = 배낭의 용량이 0일때, 아무 물건도 담을 수 없으므로 0으로 초기화. $D[0][w]$ = 아무런 물건도 배낭에 담는걸 고려하지 않았을때, 0으로 초기화. 접근법 및 구현: 전역 배열을 하나 선언한 후, 초기값을 설정한다. $i$번째 물건의 무게와 임시 배낭 용량을 확인하며 점화식 조건에 맞춰 값을 채운다. 테이블을 채워넣은 후 $D[n][w]$을 출력한다. #include &lt;bits/stdc++.h&gt;using namespace std;int bag[101][100001]; // DP 테이블int thing[101][2];int main(void){\tios::sync_with_stdio(0);\tcin.tie(0);\t\tint n, w;\tcin &gt;&gt; n &gt;&gt; w;\tfor(int i=1; i&lt;=n; i++)\t\tcin &gt;&gt; thing[i][0] &gt;&gt; thing[i][1]; // 무게, 가치 입력\t\tfor(int i=1; i&lt;=n; i++)\t{\t\tint weight = thing[i][0]; // i번째 물건 무게\t\tint val = thing[i][1]; // i번째 물건 가치\t\tfor(int j=1; j&lt;=w; j++)\t\t{\t\t\tif(weight &gt; j) // 임시 용량 초과시\t\t\t\tbag[i][j] = bag[i-1][j];\t\t\telse\t\t\t\tbag[i][j] = max(bag[i-1][j], bag[i-1][j-weight]+val); \t\t}\t}\tcout &lt;&lt; bag[n][w];}4) 동전 1 - BOJ 2293 문제: n가지 종류의 동전이 있다. 각각의 동전이 나타내는 가치는 다르다. 이 동전을 적당히 사용해서, 그 가치의 합이 k원이 되도록 하고 싶다. 그 경우의 수를 구하시오. 부가 정보 &amp; 조건 각각의 동전은 몇 개라도 사용할 수 있다. 사용한 동전의 구성이 같은데, 순서만 다른 것은 같은 경우이다. 1) 테이블 정의 $D[i]$ = $i$원을 만드는 경우의 수2) 점화식 세우기가장 값이 낮은 동전부터 하나씩 이용하여 만들 수 있는 값을 모두 고려한다.ex) 1, 2, 5원이 있다고 하자. 그리고 만들고 싶은 수는 10원이라고 하자. 1원으로만 만들 수 있는 경우의 수는 1-10까지의 수를 그 수만큼의 1원을 이용하여 만드는 것이므로 $D[1]$~$D[10]$이 1씩 증가한다.그 다음 2원으로 만들 수 있는 걸 보자. 일단 2원 하나만 써서 2원을 만들 수 있고, 3원은 1+2원, 4원은 2원+2원, 5원은 3+2원….즉, $j$라는 수를 만들기 위해 $D[j-2]$의 경우의 수만큼을 더해나가고 있다. 이는 나머지 동전에도 적용될 것이다.즉, $D[n]$의 경우의 수에 원하는 동전을 사용했을때, 그 동전의 값이 $v$라고 하면, $D[n+v] += D[n]$이 성립할 것이다.3) 초기값 설정 입력으로 주어지는 동전들을 한번씩 사용하여 바로 그 가치만큼을 바로 만들 수 있다. 이 때 주의해야할 점은 미리 반복문으로 각 동전의 인덱스에 해당하는 $D[i]$를 증가시켜놓으면 안된다. 그 이유는 이렇다. 만약 위의 예제에서 미리 값을 증가시켰다고 하자. 그러면 1원을 고려할 때 모든 인덱스에 대해 기본적으로 1씩 증가하고, 2원과 5원에 대해 초기값을 설정하므로 $D[2] = 2, D[5] = 2$가 된다. 이 때 $D[3]$을 고려할 때 $D[3] += D[3-1]$이므로 $D[3] = 2$가 된다. 2원을 고려할 때, $D[3] += D[3-2]$이므로 $D[3] = 3$이 된다. 하지만 실제로는 $3 = 1+2, 1+1+1$, 이렇게 2가지의 경우의 수가 다이다. 왜 이런 결과가 나왔는가? 왜냐하면 각각 동전을 사용했을때만 고려하며 값을 증가해나가야 하는데 미리 초기화를 시켜놓으면 1원만을 고려하는 과정에서 이미 2원만을 사용한 경우의 수가 추가되어 $D[2]$가 1만큼 증가했기 때문에, 1만을 고려하는 과정에서 이미 $1+1+1, 2+1$의 경우의 수가 이미 만족되어 버린 것이다. 따라서 미리 초기화가 아닌 각 동전을 고려할때마다 그 동전의 인덱스만 1씩 증가시켜야한다. 접근법 및 구현: 각 동전을 고려하며 현재 값 + 현재의 동전을 썼을 때의 값에 현재 값만큼 더해준다. 테이블을 채워넣은 후 $D[n]$을 출력한다. #include &lt;bits/stdc++.h&gt;using namespace std;int num[101];int d[10001];int main(void){ int n, k; cin &gt;&gt; n &gt;&gt; k; for(int i=0; i&lt;n; i++) cin &gt;&gt; num[i]; for(int i=0; i&lt;n; i++) { \tif(num[i] &gt; k) // 원하는 값 초과하면 더이상 고려 필요 x \t\tcontinue; \td[num[i]]++; for(int j=num[i]+1; j&lt;=k; j++) { d[j] += d[j-num[i]]; // 이 동전을 쓰기 전의 값만큼을 이 동전을 썼을 때의 값에 더해준다. } } cout &lt;&lt; d[k];}결론 &amp; TMI DP역시 그리디와 더불어 문제가 정말 많아 단골 문제로 자주 출제된다. 나는 Bottom-up 방식이 더 편한 것 같다. 재귀야 물러가라. 테이블 정의와 점화식을 얼마나 잘 찾느냐가 DP의 핵심이다. 원래는 DP를 이름붙인 Richard Bellman은 처음에 Programming이라는 단어 대신 Planning을 쓰려다가 마음에 들지 않아 바꿨다고 한다. Dyanmic이라는 단어도 딱히 의미 없이 그냥 간지가 나서 붙였다고 한다.Copyrightⓒ. 2022. By Seonghwan Shin. All Rights Reserved.-The End-" }, { "title": "Chapter 2. Greedy", "url": "/posts/2nd-Greedy/", "categories": "", "tags": "", "date": "2022-07-05 16:00:00 +0900", "snippet": "😋 그리디(Greedy) 알고리즘이란? 😋 Greedy..? 탐욕적..? 뭔가 욕심을 부리는 알고리즘인가..그렇다. 극한의 이득을 취해가며 문제를 풀어나가는 방식의 알고리즘이다. 그래서 Greedy라고 불린다. 하지만, 모든 알고리즘들이 그렇듯 특정 상황에만 적용 가능하다.그리디(Greedy): 정의: 현 상태에서, 가장 최적인 답을 근시안적으로 택하는 알고리즘. 여기서 말하는 가장 최적인 답의 예시를 들어보자. ex) 루트 노드에서 출발하여 가장 큰 수를 구하기여기서 우리는 직관적으로 20이 정답인걸 알 수 있다. 그러나 Greedy한 접근방법에 의하면, 첫번째 선택 과정에서 7과 8을 접해(현재 선택지들)이 중 가장 큰 수인 8을 고른다. 8이 있는 경로로 내려가고, 다음 두번째 선택 과정에서 4와 6을 접해(현재 선택지들)이 중 가장 큰 수인 6을 최종해로 결정한다.즉, 상황에 따라 가장 최적인 답의 형태는 바뀔 수 있고, 여기서는 현재 상황에서의 가장 큰 수를 골라나가는것이 최적해를 리턴하지 않으므로, Greedy가 적용될 수 없는 문제인 것이다. 조건 및 장점: 그리디 알고리즘이 적용되기 위해 2가지 조건이 성립해야한다. 1. 탐욕 선택 속성(greedy choice property) 앞의 선택이 이후에 선택에 영향을 주지 않아야한다. 즉 매 선택의 순간마다 그 상황에만 충실해 최적해를 골라 나가야한다. 앞의 선택이 이후에 선택에 영향을 주는 DP와 차별화 되는 점이다. 2. 최적 부분 구조(optimal substructure) 문제에 대한 최종 해결 방법은 부분 문제에 대한 최적 문제 해결 방법으로 구성된다. 즉, 문제에 대한 최종 해결법이 부분 문제에 대해서도 역시 해결법으로 적용된다는 의미이다. 이런 조건들을 만족하는 문제일 때, 그리디 알고리즘은 항상 최적해를 찾을 수 있다. 이런 형태의 문제들을 매트로이드(matroid) 라고 한다. 장점: 다른 알고리즘들에 비해 풀이법을 떠올리기 쉽다. 왜냐하면 이런 그리디한 풀이가 성립하려면 어떤 순서를 기준으로 값을 처리하는 경향이 다분하다. 따라서 정렬이라던가 우선순위 큐의 사용법만 알면 웬만한 문제는 풀이가 가능하다. 많은 알고리즘 중 가장 기본적이고 쉬운 형태라고도 한다. 단점 및 한계: 순간마다 하는 선택은 지역적으로는 최적이지만, 그 선택들을 계속 누적하여 최종적(전역적)인 해답을 만들었다고 해서, 그것이 최적이라는 보장은 없다. 특정 상황에만 성립하는 알고리즘으로, 적용할 수 있는지 여부를 먼저 판단해야한다. 그리디 예제1) 회의실 배정 - BOJ 1931 문제: 한 개의 회의실이 있다. 각 회의가 겹치지 않게 하면서 회의실을 사용할 수 있는 회의의 최대 개수를 찾아보자. 부가 정보 &amp; 조건 단, 회의는 한번 시작하면 중간에 중단될 수 없다. 한 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있다. 회의의 시작시간과 끝나는 시간이 같을 수도 있다. 이 경우는 시작하자마자 끝나는 것. 이 문제는 왜 그리디일까? 일단 그리디가 적용될 수 있는 문제인지는 아직 모르겠지만, 그리디한 풀이를 일단 떠올려보자. 그러면 다음과 같은 방법이 떠오른다. 회의의 끝나는 시간이 가장 빠른순으로 회의를 배정한다.과연 이 방법으로 최적해를 찾아낼 수 있을까? 만약 이 명제에 대한 반례를 찾아낼 수 있다면, 이 방법은 틀렸으며 그리디한 풀이가 적용될 수 없는 문제라고 판단할 수 있다.ex) 회의 시간 배정 예시$t$는 현재의 시간이다. 검은 줄 하나가 회의 하나를 나타내며, 왼쪽 끝은 시작 지점, 오른쪽 끝은 종료 지점이다. 만약 위의 명제에 대한 반례가 있다고 가정하자. 그렇다면, “더 늦게 끝나는 회의를 골랐을 때 더 많은 회의를 배정할 수 있는 경우의 수가 있다” 가 성립해야한다.그리디의 풀이대로라면 더 일찍 끝나는 B를 다음 회의로 배정하겠지만, 더 늦게 끝나는 A를 골라보자. 이때, A를 고른 이후에 어떤 경우의 수가 오든, B를 골랐을때에도 최소한 동일한 수의 회의를 배정할 수 있다. 그러므로, 원래 명제의 역은 틀렸다. 따라서 원래 명제가 옳으므로, 그리디한 풀이가 적용될 수 있는 문제임을 증명했다. 접근법 및 구현: 끝나는 시간이 가장 빠른 회의 순으로 정렬하되, 시작하는 시간도 가장 빠른 순으로 정렬한다. 그 이유는 시작하자마자 끝나는 회의의 존재때문이다. 예를 들어 (3, 5)와 (5, 5)의 회의가 있을때, 만약 전 회의가 3초에 끝났다면 (3, 5)를 배정하는게 이득이고, 만약 5초에 끝났다면 (5, 5)를 배정하여 시작하자마자 끝나는 회의를 하나 더 집어넣을 수 있다. C++에서 pair클래스는 first, second순으로 자동 오름차순 정렬을 해주는 기능이 있다. first에 종료 시간, second에 시작 시간을 입력받아 정렬하면 자동으로 종료 시간이 빠른 순으로, 종료 시간이 같다면 시작 시간이 빠른 순으로 정렬해줄 것이다. 정렬 후, 앞에서부터 살펴보며 회의의 시작 시간이 현재 회의의 종료 시간보다 크거나 같은 회의를 배정하면 된다. (이미 원하는 순서로 정렬해놨기에, 시작 시간만 체크하면서 바로 바로 다음 회의를 배정하면 됨) #include &lt;bits/stdc++.h&gt;using namespace std;pair&lt;int, int&gt; a[100001];int main(void){\tios::sync_with_stdio(0);\tcin.tie(0);\t\tint n;\tint cnt = 1, off = 0;\tcin &gt;&gt; n;\tfor(int i=0; i&lt;n; i++)\t\tcin &gt;&gt; a[i].second &gt;&gt; a[i].first; // 종료 시간, 시작 시간순 저장\tsort(a, a+n); // 정렬\t\toff = a[0].first; // 최초 회의 배정\tfor(int i=1; i&lt;n; i++)\t{\t\tif(a[i].second &gt;= off) // 시작 시간이 현재 회의 종료보다 빠르면 그 회의 배정\t\t{\t\t\toff = a[i].first; // 현재 회의 갱신\t\t\tcount++; // 회의 수 갱신\t\t}\t}\tcout &lt;&lt; cnt;}2) A와 B - BOJ 12904 문제: 두 문자열 S와 T가 주어졌을 때, S를 T로 바꾸는 게임이다. 문자열을 바꿀 때는 다음과 같은 두 가지 연산만 가능하다. S를 T로 만들 수 있는지 없는지 알아내라. 부가 정보 &amp; 조건 문자열의 뒤에 A를 추가한다. 문자열을 뒤집고 뒤에 B를 추가한다. 이 문제는 왜 그리디일까? 처음 봤을때는 단순한 문자열 문제로 보인다. 하지만 이 문제의 문자열의 길이는 최대 1000이다. 현재 문자열에 대해 두가지 연산을 할 수 있으므로, 한 단계마다 경우의 수는 $2^n$로 기하급수적으로 증가한다. 첫 문자열 S에서 2개의 문자열, 그 2개의 문자열에 각각 또 연산을 하면 4개의 문자열…이런식으로 말이다. 이러다가 즉 최악의 경우 21000개까지의 연산을 누적해야하므로, 당연히 시간초과가 난다.이 문제가 사실 그리디인 이유는 이렇다.역으로 T-&gt;S로 가는 연산을 생각해보자. 만약 T의 마지막 글자가 ‘A’라면, 무조건 그 전 문자열에서 첫번째 연산이 이루어진 것이다. (두번째 연산은 B를 맨 뒤 B를 추가하므로 x) 만약 T의 마지막 글자가 ‘B’라면, 그 전 문자열에서 두번째 연산이 이루어진다. 즉, 결국 무궁무진한 경우의 수 중 T를 만드는 단 하나의 경우의 수를 찾는것처럼 보이지만 S에서 T에 다다르는 경우의 수는 그 경로가 정해져있다.이게 핵심이다. 따라서 T에서 S로 역연산을 실행해서 S가 나오면 경우의 수가 존재하는 것이다. 즉, 거쳐가야만 하는 연산의 경로가 정해져있기에, 현재 문자열의 끝 글자에 따라 역연산을 진행해나가면 되기에, 그리디한 문제이다. 접근법 및 구현: T에서 S로 가는 연산은, 원래 연산의 반대이므로 첫번째 연산은 맨 뒤에서 A를 제거하는 연산, 두번째 연산은 맨 뒤에서 B를 제거한 후 문자열을 거꾸로 뒤집는 연산으로 변환한다. T의 길이-S의 길이만큼만 연산을 하고, 문자열의 길이가 동일해질때 S와 비교하여 동일하면 경우의 수 존재, 다르면 경우의 수 존재 x. string 클래스에서 마지막 문자를 제거하는 pop_back(), 문자열을 뒤집어주는 reverse()함수를 이용. #include &lt;bits/stdc++.h&gt;using namespace std;int main(void){ string s1, s2, ans; cin &gt;&gt; s1 &gt;&gt; s2; ans = s2; int len = s2.size()-s1.size(); // 연산 횟수 for(int i=0; i&lt;len; i++) { if(s2.back() == 'A') // A로 끝나면, 1번 역연산 s2.pop_back(); else // B로 끝나면, 2번 역연산 { s2.pop_back(); reverse(s2.begin(), s2.end()); } } if(!s2.compare(s1)) // S와 비교 cout &lt;&lt; 1; else cout &lt;&lt; 0;}3) 카드 정렬하기 - BOJ 1715 문제: 정렬된 두 묶음의 숫자 카드가 있다고 하자. 각 묶음의 카드의 수를 A, B라 하면 두 묶음을 합쳐서 하나로 만드는 데에는 A+B 번의 비교를 해야 한다. ex) 20장의 묶음과 30장의 묶음을 합치려면 50번의 비교가 필요하다. N개의 숫자 카드 묶음의 각각의 크기가 주어질 때, 최소한 몇 번의 비교가 필요한지를 구하는 프로그램을 작성하시오. 부가 정보 &amp; 조건 두 묶음씩 골라 서로 합쳐나간다면, 고르는 순서에 따라서 비교 횟수가 매우 달라진다. 예를 들어 10, 20, 40장의 묶음이 있을 때, 오름차순으로 고르면 (10+20)+(30+40)=100의 비교가 필요 &lt;-&gt; 10-40-20순으로 고르면 (10+40)+(50+20)=120의 비교가 필요. 이 문제는 비교적 그리디임이 직관적으로 바로 보일 것이다. 왜냐하면 비교 횟수는 두 묶음의 카드 수의 합인데, 이를 최소로 만들어 나가라면 현재 가장 카드 수가 작은 묶음 2개씩을 골라나가면 되기 때문이다. 이 문제는 따로 수학적인 증명이 필요없을 것이다. 바로 구현해보자. 접근법 및 구현: 이 문제는 접근법은 떠올리기 비교적 쉬운 문제이나, 구현에 살짝 애를 먹을 수 있다. 후보 1) vector나 배열에서 min()함수를 두번 사용해 최솟값을 두번 찾고, 그 더한 값을 집어넣는다. 이 방법의 한계는 찾은 최솟값 두 개를 제거하려면 결국 앞에서 뒤까지 탐색하며 $O(n)$에 매번 제거를 해줘야한다. min()함수와 만들어진 합을 집어넣는 과정이 $O(1)$인건 좋으나, 전 묶음을 다 보려면 $O(n)$에 매 과정마다 제거하는 과정이 $O(n)$이므로 $O(n^2)$의 시간복잡도를 가져 시간초과이다. 후보 2) 매 루프마다 sort()를 통해 정렬하며 앞에서 두번째 까지의 원소를 찾아 더한 후, 그 값을 집어넣는다. 이 방법은 최솟값 찾기, 최솟값 제거, 더한 값 삽입까지는 각각 $O(1)$에 이뤄낼 수 있으나, 매 루프마다 정렬을 해야하므로 가장 빠른 정렬 방법을 사용하더라도 $O(N log N)$이므로 역시 전과 동일하게 전 묶음을 다 보는 과정을 곱하면 $O(N^2 log N)$이 될 것이다. 후보 3) 우선순위 큐를 사용해 최소 원소 두개를 리턴한 후, pop하며, 그 더한 값을 push한다. 이는 각각 $O(1)$, $O(log N)$, $O(log N)$에 이루어진다. 즉 하나의 루프마다 $O(log N)$이면 처리가 가능하므로, 최종적인 시간 복잡도는 $O(N log N)$에 처리가 가능하다. 여기서 잠깐, 우선순위 큐와 그 STL:우선순위 큐란? pop을 할 때, 가장 먼저 들어온 원소가 나오는 대신(원래 큐의 정의) 우선순위가 가장 높은 원소가 나오는 큐(우선순위의 종류는 달라질 수 있음)STL: 함수 형태 동작 방식 시간복잡도 매개 변수 push() 값을 우선순위 큐에 삽입한다. $O(log N)$ 집어넣을 값 pop() 값을 우선순위 큐에서 제거한다. $O(log N)$ 제거할 값 top() 값을 우선순위 큐에서 리턴한다. (제거는 x) $O(1)$ 리턴할 값 따라서, 여기서는 부모 노드가 자식 노드보다 항상 작은 최소 힙(heap)을 사용한 우선순위 큐를 사용하면, 금방 구현할 수 있다.#include &lt;bits/stdc++.h&gt;using namespace std;int main(void){\tios::sync_with_stdio(0);\tcin.tie(0);\t\tint n;\tint sum = 0, tmp = 0;\tcin &gt;&gt; n; if(n==1) { cout &lt;&lt; 0; return 0; }\t\tpriority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q; // 최소 힙\t\tfor(int i=0; i&lt;n; i++)\t{\t\tint x; \t\tcin &gt;&gt; x;\t\tq.push(x);\t}\twhile(!q.empty()) // 큐에 원소가 있는 동안\t{\t\tfor(int i=0; i&lt;2; i++) // 최솟값 2개 더하고 pop\t\t{\t\t\ttmp += q.top();\t\t\tq.pop();\t\t}\t\tsum += tmp; // 연산 값 누적\t\tif(q.empty()) \t\t\tbreak;\t\tq.push(tmp); // tmp값 push\t\ttmp = 0;\t}\tcout &lt;&lt; sum;}결론 &amp; TMI 그리디는 DP(Dynamic Programming)와 양대산맥으로 가장 기본적이며 많은 유형의 문제를 가지고 있는 알고리즘이다. 적용할 수 있는 상황이 제한되어있다. 주로 정렬, 우선순위 큐, 와 같이 특정 순서나 우선순위가 사용되는 기법과 자주 적용된다. 보통 문제가 그리디임을 바로 캐치해내기 힘들기에, 이것저것 해보다가 안되면 혹시 그리디인가? 라는 생각을 해보자. (이왜그) 현재 내 백준 알고리즘 태그 순위 1등이다Copyrightⓒ. 2022. By Seonghwan Shin. All Rights Reserved.-The End-" }, { "title": "Chapter 1. Divide & Conquer", "url": "/posts/1st-Divide-and-Conquer/", "categories": "", "tags": "", "date": "2022-03-21 15:50:00 +0900", "snippet": "분할 정복 알고리즘(Divide and Conquer)이란? ???: 그냥 말 그대로 문제를 분할해서 정복하는거 아닌가?맞다.이게 맞는다고?사실 알고리즘의 이름만을 보고 뭔지 대충 감이 잡히는게 있고 그렇지 않은 것도 있다. 분할 정복의 경우는 아마 대부분 전자에 속할 듯 싶다.분할 정복(Divide and Conquer) : 정의: 어렵고 복잡한 문제를 비교적 쉬운 간단한 문제들로 쪼개서(Divide) 그 문제들을 각개 정복(Conquer) 해나가는 것. 구조: 분할(Divide): 문제를 더 이상 분할할 수 없을때까지 동일한 유형의 부분문제(subproblem) 들로 나눔. 분할할 수 없을때란, 더이상 답을 분할하지 않고 곧장 풀 수 있는 충분히 “쉬운” 문제를 마주쳤을때를 말한다. 이런 문제를 \"Base case\"라고 말한다. “동일한 유형”이라는 점에도 주목해야한다. 분할 정복은 같은 성질(형태)를 가진 부분문제로 쪼개고 그 문제들을 다시 합치기에 스스로를 참조하고 호출하는 재귀(recursion) 기법이 사용된다. 정복(Conquer): 분할 과정이 끝난 후 마주친 Base case 문제들을 푼다. (가장 작은 단위의 하위 문제) 병합(Merge): 하위 문제들의 정복 결과(답), 즉 부분해(解) 들을 합쳐나가면서 원래 문제에 대한 결과를 도출한다. 조건 및 장점: 분할 정복을 적용하려면 문제를 둘 이상의 부분 문제로 나누는 자연스러운 방법이 있어야 하며, 비슷한 맥락에서 부분 문제의 답을 조합하여 원래 문제의 답을 계산하는 효율적인 방법이 있어야 한다. ex) 주어진 수들을 오름차순으로 정렬 - 의사코드로 표현 오름차순_정렬(숫자 배열 k, 배열 크기 n) { while(n &gt; 1) 입력받은 배열을 반으로 계속 쪼갬 if(n &lt;= 1) 탈출; 쪼개진 배열 2개를 비교하며 정렬해 새로운 배열 생성 ... 최종적으로 전부 정렬된 배열 return. } ↑ 오름차순 정렬 의사코드 ↑ 재귀 형태를 이용하기에 당연히 각 부분 문제마다 탈출 조건(base condition) 이 존재해야한다. 장점: 문제를 쪼개서 해결함으로써 어려운 문제를 푸는데 시간 단축 및 정확한 답을 구할 수 있다. 단점 및 한계: 함수를 재귀적으로 호출한다는 점에서 호출 횟수가 커질 수 있고, 데이터를 보관하며 진행되기에 과도한 메모리가 사용될 가능성도 있다. 가장 치명적인것은 분할 과정에서 풀기 “쉬운” 문제까지 분할한다고 했는데, 과연 그 기준이 무엇이냐이다. 이 “쉬운” 문제를 정의하는 것이 오히려 애매하고 어려운 파트다. 1) 병합/합병 정렬(Merge sort)정렬(Sorting): 정렬: 항목들을 체계적으로 정리하는 과정, 즉 어떤 기준을 가지고 그에 맞게 배치하는것. 어떤 방식으로 정렬할지는 물론 상황에 따라 다르지만 보통 숫자들이 주어졌을때는 오름차순으로, 문자열이 주어졌을때는 사전순으로 정렬하는 등의 일반적인 정렬들을 생각해보자. 선택, 삽입, 버블 등의 정렬은 $O(n^2)$의 시간복잡도를 가지는 대표적인 정렬 알고리즘이다. 하지만 이번에 알아볼 병합 정렬은 $O(n log n)$의 시간 복잡도를 가진다. 병합 정렬: 입력이 2개의 부분문제로 분할된다. 부분문제의 크기는 1/2로 감소하고, 개수는 2배로 늘어나는 분할 정복 알고리즘이다. n개의 숫자가 주어졌다고 하자. n/2개씩 2개의 부분문제로 분할하고, base condition에 도달시 2개의 부분문제를 정렬시키며 합병하여 정렬(정복)한다. 즉, 합병 과정이 정복 과정인 셈이다. 시간복잡도는?정렬의 시간복잡도는 일반적으로 숫자의 비교 횟수로 나타낸다. 입력이 N개 주어졌다고 가정하자. 분할 부분에서는 각 층(내려가면서 1, 2, 3…k층)마다 함수 호출은 $2^k$번 일어난다. 즉 1+2+4+…$2^k$ = $2N-1$ → $O(N)$의 시간복잡도를 가진다.병합 파트를 보자. 이번에는 각 층(내려가면서 1, 2, 3..k층)마다 숫자 비교횟수를 보면 결국 각 층마다 N번 비교 연산이 일어난다. 예를 들어 1층을 보면 ({27, 38}, {3, 43}, {9, 82}, {10})이 있는데, 결국 모든 숫자를 한번씩 들여다봐야 되기에(비교), 그 횟수는 입력 크기에 비례한다. 즉, 그리고 층의 갯수는 N = $2^k$로 표현될때의 $k$개이다. 즉 병합 과정에서의 시간복잡도는 $O(Nk)$. 이때 $k$는 $log_2N$이므로 최종적으로 $O(NlogN)$이다. 결론: 병합정렬의 시간복잡도는 $O(NlogN)$이다.공간복잡도는?병합 정렬은 병합 과정에서 생기는 부분 정렬된 배열들을 저장해 나가는 별도의 배열이 필요하기 때문에 $O(N)$이다.동작 코드:void merge_sort(int start, int end) // 분할 함수{ if(end == start+1) // 배열 길이가 1이면 탈출 return; int mid = (start+end)/2; // 배열을 이등분하기 위한 중간 인덱스 설정 merge_sort(start, mid); // 왼쪽 배열 나누기 merge_sort(mid, end); // 오른쪽 배열 나누기 merge(start, end); // start부터 end까지 정렬} 분할 과정은 이렇다. mid인덱스를 설정하여 이등분할 지점을 고른다. 그 후 왼쪽 시작 start 인덱스 부터 mid, mid부터 오른쪽 끝 end까지의 2개로 나누어 재귀적으로 함수를 호출한다. (주의, 실제로 배열이 나뉜건 아니고, 함수 호출을 통해 그때그때 배열이 관념적으로 나뉘었다고 생각). 그러다가 하나의 숫자만 남을때까지 나누면 return하여 merge함수를 통해 정렬 및 합병을 시작한다. void merge(int start, int end){ int mid = (start+end)/2; int lidx = start; // 왼쪽 배열의 시작 인덱스 int ridx = mid; // 오른쪽 배열의 시작 인덱스 for(int i = start; i &lt; end; i++) { if(lidx == mid) tmp[i] = arr[ridx++]; // 1 else if(ridx == end) tmp[i] = arr[lidx++]; // 2 else if(arr[lidx] &lt;= arr[ridx]) tmp[i] = arr[lidx++]; // 3 else tmp[i] = arr[ridx++]; // 4 } for(int i = st; i &lt; en; i++) arr[i] = tmp[i]; } 합병 과정은 이렇다. 시작 index가 start, 끝 index가 end인 배열을 가지고 합병을 시작한다. mid는 아까 merge_sort함수에서 명시적으로 나누어놨던 그 지점을 가져오기 위해 있는 변수이다. lidx와 ridx는 왼쪽 배열과 오른쪽 배열의 시작 index이다. 반복문을 살펴보자. arr배열은 정렬할 원래 배열, tmp는 병합을 하며 저장해 나갈 배열이다. 왼쪽 배열의 끝까지 탐색했을때는 저절로 오른쪽 배열의 원소를 넣고 인덱스를 증가시켜라이다. 이 말은, 왼쪽 배열의 모든 원소가 현재 오른쪽 배열의 arr[ridx]보다 작았다는 뜻이된다. 반대로 오른쪽 배열의 끝까지 탐색했을때는 저절로 왼쪽 배열의 원소를 집어넣고 인덱스를 증가이다. 이 경우는 1번의 정반대이다. 왼쪽 배열과 오른쪽 배열 현 인덱스 원소끼리 비교하여 왼쪽이 작거나 같으면 왼쪽 원소를 넣고 인덱스 증가이다. 이 줄로 인해서 안정 정렬(stable sort) 특성을 가지게 된다. 안정 정렬이란, 동일한 특성이라면 그 순서 원래대로 그대로 가져간다는 의미이다. 값이 같아도 원래 순서대로 왼쪽 인덱스의 값을 넣기에 성립된다. 3번의 반대일 경우 오른쪽 배열 현 인덱스 원소를 집어놓고 인덱스 증가이다. 그 후 원래 배열 arr에 tmp를 복사한다. 2) 퀵 정렬(Quick sort)퀵 정렬: 입력이 2개의 부분문제로 분할된다. 부분문제의 크기는 일정하지 않다. 그 이유는 pivot이라는 녀석때문이다. n개의 숫자가 주어졌다고 하자. n/2개씩 2개의 부분문제로 분할하고, base condition에 도달시에는 전체가 다 정렬이 되어있다. 그 이유는 퀵 정렬은 정복을 먼저 하고 그 후에 분할을 해 나가기 때문이다. 동작 방식은 이렇다. pivot이라는 하나의 원소를 정해 pivot보다 작은 원소들은 pivot의 왼쪽으로, 큰 원소들은 오른쪽으로 보낸다. (이때, 순서는 상관없다. 그저 방금 말한 조건만 만족하면 된다.) 그럼 pivot을 기준으로 왼쪽 오른쪽에 배열이 생길것이다. (pivot이 최대, 최소 값이 아닌 이상) 그 각각의 배열에서 재귀적으로 새로운 pivot을 설정하고 이 과정을 되풀이 하다보면 결국 숫자들이 자기 자리를 찾아가면서 전체 정렬이 될것이다. 시간복잡도는?입력이 N인 배열이 주어졌다고 하자. 퀵 정렬은 아까 말했듯이 정복을 먼저한다. 즉, pivot을 옳은 위치로 보내는 행위를 말한다. 정복 부분에서 각 층(내려가면서 1, 2, 3…k층)에서 pivot을 옳은 위치로 보내려면 결국 N개의 숫자를 모두 확인해야한다. 즉 pivot을 잘 설정해서 정확히 배열을 이등분 해나가는 과정을 반복하면 병합 정렬과 같은 $O(NlogN)$의 시간복잡도를 가진다.하지만 주의할점이 있다. 바로 pivot을 어떻게 정하냐인데, 만약 오름차순으로 이미 정렬된 배열이 입력으로 주어졌다고 하자. 그러면 pivot을 만약 첫번째 원소로 잡을 경우 1의 옳은 자리는 원래 자리 그대로다. 그 다음에 1의 오른쪽에만 배열이 남아있기에 과정을 반복한다. 이러다가 보면 결국 하나의 층에서 하나의 원소만을 배제시키는 것이다.결국 이 경우의 시간복잡도는 $N+(N-1)+(N-2)+…+1 = N(N+1)/2 → O(N^2)$이다!!! 결론: 퀵 정렬의 시간복잡도는 평균적으로 $O(NlogN)$이지만, 최악의 경우 $O(n^2)$이 될 수 있으니 pivot을 잘 고르자.공간복잡도는?퀵 정렬은 따로 새로운 배열을 생성하는게 아닌 원래 기존 배열에서의 원소의 자리를 바꿔나가기 때문에 추가 메모리는 필요 없다. 그저 평균 함수 호출의 수가 $log(N)$ 정도라고 한다.동작 코드:void quick_sort(int start, int end) { if(end &lt;= start+1) return; int pivot = arr[start]; int l = st+1; // 왼쪽 끝 포인터 int r = en-1; // 오른쪽 끝 포인터 while(1) { while(l &lt;= r &amp;&amp; arr[l] &lt;= pivot) l++; while(l &lt;= r &amp;&amp; arr[r] &gt;= pivot) r--; if(l &gt; r) break; swap(arr[l], arr[r]); } swap(arr[st], arr[r]); quick_sort(st, r); quick_sort(r+1, en);} 과정은 이렇다. base condition은 배열의 크기가 1이 되었을때이고, pivot은 가장 왼쪽 인덱스의 원소라고 가정한다. (어차피 어떤 최적화된 pivot을 골라 맨 왼쪽으로 보내는것과 과정은 같다) l과 r은 각각 원소들의 자리를 바꾸기 위한 포인터이다. l은 pivot보다 큰 값을 찾을때까지 오른쪽으로 움직이고(찾으면 멈춤), r은 작은 값을 찾을때까지 왼쪽으로 움직인다(동일). 그러다가 l과 r의 값이 정해지면 그 인덱스끼리의 값을 바꾼다. 큰 값이 왼쪽에 있고 작은 값이 오른쪽에 있는게 말이 안되지 않는가? 그래서 바꾸는것이다. 이러다보면 l의 왼쪽에는 항상 pivot보다 작은 원소들이, r의 오른쪽에는 항상 pivot보다 큰 원소들이 자리잡게 된다. 그러다가 l과 r이 교차하면 그때 pivot과 r인덱스의 원소를 교환한다. 이후 pivot왼쪽과 오른쪽 배열에 대해 각각 과정을 반복한다. 3) 선택 문제(Quick Selection)선택 문제는 n개의 숫자들 중에서 k번째로 작은 숫자를 찾는 문제이다.어떤 알고리즘을 생각할수 있는가? 보통 이런걸 생각할것이다. 배열 전체를 탐색하며 최소 숫자를 k번 찾는다. (찾은 숫자는 제거) 배열을 오름차순으로 정렬한 후, k번째 숫자를 찾는다.그러나 위의 알고리즘들은 각각 최악의 경우 $O(kN)$과 $O(NlogN)$의 수행 시간이 걸린다. 이를 해결하기 위해 분할 정복을 사용해보자.이런 발상은 어떨까? 숫자를 찾기 위해 전체 배열을 다 찾지말고, 어떤 숫자를 기준으로 왼쪽에는 작은 숫자, 오른쪽에는 큰 숫자만 있는 상태를 만들 수 있다면, 찾고자 하는 k번째 숫자가 어느쪽에 속해있는지에 따라 둘 중 한쪽에만 눈을 돌리면 될것이다. 그게 바로 이진탐색(binary search)이다!이 상태..익숙하지 않은가? 바로, 방금 알아본 퀵 정렬의 파티션(partition) 부분과 동일하다. 동작방식은 이렇다. 첫 스텝은 퀵 정렬에서 했던 파티션을 먼저 수행한다. 퀵 정렬은 전체 배열을 다 정렬하기 위해 파티션 후 pivot왼쪽과 오른쪽 배열을 재귀적으로 모두 살펴보았다. 이에 반해, 이 문제에서는 아까 언급했듯이 숫자가 pivot의 index보다 작은지(파티션 후), 큰지에 따라 어느 한쪽만 계속 살펴나가면 된다. 그러다가 pivot의 상대적인 위치와 찾고자 하는 k가 같으면 출력한다. 여기서 말하는 pivot의 상대적인 위치란 처음 전체 배열에서의 pivot의 절대적인 위치가 아니라 배열이 쪼개져 나가면서 배열 시작 지점과 끝나는 지점이 바뀌는데, 그 쪼개진 배열 안에서의 위치를 말한다. 시간복잡도는?파티션 과정이 잘 돼서 배열이 평균적으로 절반씩으로 잘 쪼개져나가며 필요없는 숫자들을 잘 버린다고 가정하면, 어느 한쪽 배열만 탐색하기에 평균적인 시간복잡도는 $O(n+\\frac{1}{2}n +(\\frac{1}{2})^2n+…+ (\\frac{1}{2})^in) = O(n)$이다.그러나 퀵 정렬과 마찬가지로 pivot의 선정이 잘못되면 마찬가지로 최악으로 $O(n^2)$의 시간복잡도를 가질것이다. 결론: pivot을 잘 고르자.공간복잡도는?퀵 정렬과 마찬가지로 별도의 메모리를 사용하지 않았으므로, 통상적으로는 $O(1)$이나, 함수 호출 횟수에 따라 차이는 있을 수 있다.동작 코드void selection(int st, int en, int k) { \tif(en &lt;= st+1) { // 길이가 1이면 그 원소 출력\t\tcout &lt;&lt; arr[st]; \t\treturn;\t}\tint mid = (st+en)/2; // pivot 선정\tswap(arr[st], arr[mid]);\tint pivot = arr[st];\t\tint l = st+1; // 포인터 l\tint r = en-1; // 포인터 r\tint l_size;\twhile(1){ // partition\t\twhile(l &lt;= r &amp;&amp; arr[l] &lt;= pivot) l++;\t\twhile(l &lt;= r &amp;&amp; arr[r] &gt;= pivot) r--;\t\tif(l &gt; r) break; \t\tswap(arr[l], arr[r]);\t}\tswap(arr[st], arr[r]);\t\tl_size = r-st; // 왼쪽 배열 사이즈\t\tif(k &lt;= l_size) selection(st, r, k);\telse if(k == l_size+1){\t\tcout &lt;&lt; arr[r];\t\treturn;\t}\telse\t\tselection(r+1, en, k-l_size-1);} 과정은 이렇다. st, en, k는 각각 배열의 시작, 끝, 숫자의 위치이다. 첫 줄은 길이가 1일때까지 그 원소를 찾지 못한 경우, 즉 마지막까지 원소를 못 찾았을때 그 원소가 답이기 때문에 출력하는것이다. 그 다음은 pivot선정 과정, 이 코드에서는 단순히 중간에 있는 값을 pivot으로 정해 맨 앞과 위치를 바꾼다. 그 다음은 quick sort와 동일한 과정을 거친다. l_size는 왼쪽 배열의 크기이다. 즉 k가 이 크기보다 같거나 작으면 왼쪽 배열중에 찾는 수가 있고, 만약 l_size+과 동일하다면, 즉 바뀐 pivot의 위치와 k가 동일하다면 그 원소가 우리가 찾는 수이고, 이외의 경우는 오른쪽 배열에서 k에서 l_size+1을 뺀 값의 위치의 수를 찾기 시작한다. 4) 최근접 점의 쌍 찾기 (Closest pair)최근접 점 쌍 찾기는 2차원 평면상의 n개의 점이 입력으로 주어질 때, 거리가 가장 가까운 한 쌍의 점을 찾는 문제이다.어떤 알고리즘을 생각할수 있는가? 보통 이런걸 생각할것이다. 두 점끼리의 가능한 모든 경우의 수, 즉 ${n\\choose2}$ 의 경우의 수의 거리를 모두 계산한뒤 최솟값을 찾는다.하지만 이 방법은 $n(n-1)/2 = O(n^2)$의 시간복잡도가 걸리기 때문에 비효율적이다.역시, 이를 해결하기 위해 분할 정복을 사용해보자. 동작방식은 이렇다. x좌표를 기준으로 모든 점들을 정렬한 후, 중간 x좌표를 기준으로 왼쪽 오른쪽 두 부분으로 나뉘어 그 부분에서의 최소 거리를 찾고, 가운데 지점에서 현재 구한 ±최소 거리 내의 점들끼리의 최소 거리를 비교하는 것이다. 단, 점이 3개이하로 모인 부분이 나올경우, 그 때에는 그 점들끼리의 최소 거리를 직접 구한다. 시간복잡도는?이 문제는 분할 과정은 병합 정렬과 같이 절반씩 쪼개지고, 그 층에서 가운데 있는(±최소 거리)점끼리의 최소 거리를 구할때, y좌표끼리 정렬하는 과정이 있다. 이런 과정을 다 고려하면 층마다의 소요 시간은 $O(nlogn)$, 그리고 층 수가 $log n$이므로 총 시간복잡도는 $O(nlog^2n)$이다.공간복잡도는?별도의 메모리를 사용하지 않았으므로, 통상적으로는 $O(1)$이나, 함수 호출 횟수에 따라 차이는 있을 수 있다.동작 코드void closest_pair(int st, int en, ll val){\tif(min_val == 0) // 점의 거리가 0인 경우가 나오면 즉시 return\t\treturn;\t\tif(en-st&lt;=2) // 점의 개수가 3개 이하일때\t{\t\tif(en-st == 1)\t\t\tmin_val = min({dist(arr[st], arr[en]),val});\t\telse\t\t\tmin_val = min({dist(arr[st], arr[st+1]), dist(arr[st+1], arr[en]), dist(arr[st], arr[en]), val});\t\treturn;\t}\t\tint r = (st+en)/2;\tclosest_pair(st, r, min_val);\tclosest_pair(r+1, en, min_val);\t\tint i = r;\tint j = r;\tint l_max = arr[r].first - sqrt(min_val) - 1; // 왼쪽으로 현재 최소 거리 뺌\tint r_max = arr[r].first + sqrt(min_val) + 1; // 오른쪽으로 현재 최소 거리 더함\twhile(i&gt;=1 &amp;&amp; arr[i].first &gt; l_max) // 최소 거리 내 제일 왼쪽 점 구하기\t\ti--;\twhile(j&lt;=en &amp;&amp; arr[j].first &lt; r_max) // 최소 거리 내 제일 오른쪽 점 구하기\t\tj++;\t\tint a = 0;\tint b = 0;\tfor(; i&lt;=r; a++, i++) // 가운데 있는 점들 임시 저장\t{\t\ttmp1[a].first = arr[i].first;\t\ttmp1[a].second = arr[i].second;\t}\tfor(r = r+1; r&lt;j; b++, r++)\t{\t\ttmp2[b].first = arr[r].first;\t\ttmp2[b].second = arr[r].second;\t}\t\tfor(int i=0; i&lt;a; i++) // 가운데 있는 점들끼리 거리 계산\t{\t\tfor(int j=0; j&lt;b; j++)\t\t{\t\t\tmin_val = min(dist(tmp1[i], tmp2[j]), min_val);\t\t}\t}\treturn;}코드 동작 방식은 주석으로 설명을 마치겠다. 코드가 잘 작동하긴 하는데 데이터가 큰 케이스에 대해서는 시간 초과가 나는듯 하다. 추후에 개선된 코드로 업데이트 할 예정.결론 &amp; TMI 분할 정복에 대한 소개를 진행했다. 분할 정복을 적용한 케이스를 4가지 알아보았고, 각각의 시간/공간복잡도에 대해서도 알아보았다. 분할 정복은 무조건 좋은줄만 알았는데 효율적으로 작동할 수 있는 조건이 있고, 그럴때에만 적용할 수 있다는걸 새로 배웠다. 최근접 점 쌍 코드는 현재 이 블로그 글을 쓰는 이 시점에도 수정중이다. 더 나은 코드로 돌아오겠습니다. ^^ 그럼, 다음 수업에 돌아오겠습니다." }, { "title": "Introduction To Computer Algorithm", "url": "/posts/Introduction/", "categories": "", "tags": "", "date": "2022-03-17 14:30:00 +0900", "snippet": "알고리즘(Algorithm)이란? 일반적 정의 : 단순히 어떤 문제를 해결하기 위한 방법 또는 이론 프로그래밍적 정의 : 어떠한 입력이 주어졌을때 그것을 기반으로 원하는 결과(출력)를 얻어내기 위한 정형화된 단계 절차 ↑ 알고리즘 종류 레이더 차트 ↑ 시간/공간복잡도(Time/Space Complexity)란?알고리즘의 효율성: 시간 복잡도 (Time Complexity) 시간 복잡도는 말 그대로 자료 또는 입력의 수(n)이 주어졌을 때 프로그램이 결과를 도출하는데 걸리는 연산의 수, 즉 소요 시간(f(n))을 말한다. 이를 Big-O 표기법으로 주로 나타낸다. 물론 Big-Omega나 Big-Theta같은 표기법도 존재하나 잘 사용되지 않는다. Big-O 표기법 f(n)의 점근적 상한(asymptotic upper bound)을 나타낸다. 어떤 식 f(n)이 있으면, 그 식의 최고 차항을 가져오면 된다. ex) f : 내가 아무리 안 좋아도 쟤(g)보단 성능이 나쁘지 않다 결국 아무리 맞는 출력을 내놓는 프로그램이더라도 이 시간복잡도가 너무 크다면 결코 효율적인 프로그램이라고 말할 수 없다. 다양한 알고리즘들이 각각 어떤 시간복잡도를 갖는지는 나중 포스트에서 다루겠다. 공간복잡도 (Space Complexity) 공간 복잡도도 직관적으로 이해하면 쉽다. 프로그램 실행을 위해 결국 얼마만큼의 공간(메모리)가 필요하느냐, 이다. 앞서 언급한 Big-O 표기법을 똑같이 주로 사용한다. 하지만 여기 공간복잡도에 대한 명언을 한번 짚고 넘어가자. ??? : 공간복잡도는 그냥 메모리 추가만 하면 됩니다. 농담이다. 사실 그저 현실에서는 시간복잡도보다 중요성이 떨어진다는 것을 말하기 위함이다. 그 이유는 하드웨어&amp;소프트웨어의 발달로 인해 슈퍼 컴퓨터 등의 개발 이후로는 공간에 대한 걱정은 비교적 사그라들었기 때문이다. 물론 메모리를 적게 쓸수록 좋은건 맞지만 알고리즘의 효율성에 대해서는 시간적인 측면을 고려하는 경향이 크다. 다만, 임베디드 같은 한정된 하드웨어 환경에서는 공간복잡도가 중요해질 수 있다. Git 및 GitHubGit: 리누스 토르발스가 개발한 분산형 버전 관리 시스템 (Version Control System).어떨때 쓰는가?어떤 프로젝트를 만들때, 과연 개발자 또는 프로그래머 한 명이 모든걸 다 수행할 수 있을까? 물론 가능할 수도 있으나, 그 효율성이나 수행 시간에서 분명히 나쁜 측면을 찾을 수 있을것이다.그래서 협업할 수 있는 공간(Github)을 만들어서 서로의 작업물을 점점 추가(add)하며, 기여(commit)하며, 버전을 계속 새롭게 밀어낸다(push).물론 정확한 설명은 아니지만, 저런 의미라고 생각하면 쉽다저 단어들을 굳이 쓴 이유는 저것들이 바로 GIT의 주요한 명령어들이기 때문이다.GIT 주요 명령어 git init 원하는 경로에 Git 저장소를 만듬. (Initialize) git status 현재 Git 상태를 보게 해줌. 이게 되게 편한게 본인이 어떤 변경사항을 만든다면 그걸 인식하고 직관적으로 현재 상태를 보여준다. git add Git에 올라가기 전에 원하는 파일들을 대기실(staging area)로 추가함 ex) git add . → .은 현재 디렉토리에 있는 모든 파일을 add 하겠다는것. git commit -m[\"message\"] 수정된 사항들에 대한 기록을 남긴다. 이 commit을 통해 버전의 차이가 생기며, 기록을 해놨기 때문에 다시 다운그레이드 등이 가능하다. git push GITHUB같은 저장소에 commit된 수정 소스들을 업로드함. Github: 대표적인 무료 Git 저장소. 주요 내용은 다음과 같다. 출시일 본사 서비스 개발 언어 2008.02.08 Microsoft Git 호스팅, 버전 관리 Ruby 마크다운 언어를 기반으로 한 Jekyll을 이용해 본인의 Github계정에 블로그를 생성할 수 있다. 그곳이 이곳이다(재귀). 테마 설치도 가능하다. (Chirpy Theme 사랑합니다 ♥) 요즘은 기업에서 포트폴리오로 대놓고 GITHUB 주소를 달라고 하는 곳이 많다고 하다. 그 정도로 영향력이 있는 도구이다. 결론&amp;TMI 알고리즘에 대한 간략한 소개를 진행했다. 시간/공간 복잡도에 대한 개념을 배웠다. (프로그램 짤 때 고려사항) GIT 명령어를 하도 쓰다보니 이제 좀 익숙해진것 같다 .아닌가? 이 Chirpy 테마는 gh-pages 라는 새로운 branch를 생성하여 그 branch를 연결하여 사용하는, 다른 테마와는 조금 다른 적용 방식을 가지고 있었다. 그래서 테마 적용하는데만 오류가 계속 떠서 몇시간을 잡아먹혔다. 그럼, 다음 수업에 돌아오겠습니다." } ]
