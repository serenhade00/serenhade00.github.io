---
layout: post
title: Chapter 1. Divide & Conquer
date: 2022-03-21 15:50
math: true
 
---

## 분할 정복 알고리즘(Divide and Conquer)이란?
***

> ~~**???: 그냥 말 그대로 문제를 분할해서 정복하는거 아닌가?**~~


**맞다.** 

<span style ="font-size:10px">~~이게 맞는다고?~~</span>

사실 알고리즘의 이름만을 보고 뭔지 대충 감이 잡히는게 있고 그렇지 않은 것도 있다. **분할 정복**의 경우는 아마 대부분 전자에 속할 듯 싶다. 

### **분할 정복(Divide and Conquer) :**

<img src = "https://cdn.kastatic.org/ka-perseus-images/db9d172fc33b90e905c1213b8cce660c228bb99c.png" width="600" height ="400" />

* <mark>정의:</mark> 
    * 어렵고 복잡한 문제를 비교적 쉬운 간단한 문제들로 **쪼개서(Divide)** 그 문제들을 각개 **정복(Conquer)** 해나가는 것.


* <mark>구조:</mark>
    * 분할(Divide): 
        - 문제를 더 이상 <span style ="color:#F15F5F">분할할 수 없을때</span>까지 <span style="color:skyblue">동일한 유형</span>의 **부분문제(subproblem)** 들로 나눔. 


        - <span style ="color:#F15F5F">분할할 수 없을때</span>란, 더이상 답을 분할하지 않고 곧장 풀 수 있는 충분히 *"쉬운"* 문제를 마주쳤을때를 말한다. 이런 문제를 `"Base case"`라고 말한다. 


        - <span style = "color:skyblue">"동일한 유형"</span>이라는 점에도 주목해야한다. 분할 정복은 같은 성질(형태)를 가진 부분문제로 쪼개고 그 문제들을 다시 합치기에 스스로를 참조하고 호출하는 **재귀(recursion)** 기법이 사용된다. 


    * 정복(Conquer): 
        - 분할 과정이 끝난 후 마주친 `Base case` 문제들을 푼다. (가장 작은 단위의 하위 문제)


    * 병합(Merge): 
        - 하위 문제들의 정복 결과(답), 즉 **부분해(解)** 들을 합쳐나가면서 원래 문제에 대한 결과를 도출한다.


* <mark>조건 및 장점:</mark>
    * 분할 정복을 적용하려면 문제를 둘 이상의 부분 문제로 나누는 자연스러운 방법이 있어야 하며, 비슷한 맥락에서 부분 문제의 답을 조합하여 원래 문제의 답을 계산하는 효율적인 방법이 있어야 한다.

        ex) 주어진 수들을 오름차순으로 정렬 - [의사코드](https://namu.wiki/w/%EC%9D%98%EC%82%AC%EC%BD%94%EB%93%9C)로 표현

        ```
        오름차순_정렬(숫자 배열 k, 배열 크기 n)
        {
            while(n > 1)
                입력받은 배열을 반으로 계속 쪼갬
            if(n <= 1)
                탈출;
            쪼개진 배열 2개를 비교하며 정렬해 새로운 배열 생성 
            ...
            최종적으로 전부 정렬된 배열 return.
        }
        ```

    <p align = "center"> ↑ 오름차순 정렬 의사코드 ↑ </p> 


    * 재귀 형태를 이용하기에 당연히 각 부분 문제마다 **탈출 조건(base condition)** 이 존재해야한다. 

    * 장점: 문제를 쪼개서 해결함으로써 어려운 문제를 푸는데 시간 단축 및 정확한 답을 구할 수 있다.

* <mark>단점 및 한계:</mark>
    * 함수를 재귀적으로 호출한다는 점에서 호출 횟수가 커질 수 있고, 데이터를 보관하며 진행되기에 과도한 메모리가 사용될 가능성도 있다. 
    * 가장 치명적인것은 분할 과정에서 풀기 *"쉬운"* 문제까지 분할한다고 했는데, 과연 그 **기준**이 무엇이냐이다. 이 *"쉬운"* 문제를 정의하는 것이 오히려 [애매하고 어려운 파트](https://namu.wiki/w/%EC%95%84%EC%9D%B4%EB%9F%AC%EB%8B%88)다.

## 1) 병합/합병 정렬(Merge sort)
***

### 정렬(Sorting):

* 정렬: 항목들을 체계적으로 정리하는 과정, 즉 어떤 **기준**을 가지고 그에 맞게 배치하는것.


* 어떤 방식으로 정렬할지는 물론 상황에 따라 다르지만 보통 숫자들이 주어졌을때는 **오름차순**으로, 문자열이 주어졌을때는 **사전순**으로 정렬하는 등의 일반적인 정렬들을 생각해보자. 


* 선택, 삽입, 버블 등의 정렬은 $O(n^2)$의 시간복잡도를 가지는 대표적인 정렬 알고리즘이다. 하지만 이번에 알아볼 병합 정렬은 $O(n log n)$의 시간 복잡도를 가진다.

### 병합 정렬:

* 입력이 2개의 부분문제로 분할된다. 부분문제의 크기는 1/2로 감소하고, 개수는 2배로 늘어나는 분할 정복 알고리즘이다. 


* n개의 숫자가 주어졌다고 하자. n/2개씩 2개의 부분문제로 분할하고, base condition에 도달시 2개의 부분문제를 정렬시키며 합병하여 정렬(정복)한다. 즉, **합병 과정**이 **정복 과정**인 셈이다. 

<img src = "https://media.vlpt.us/images/devjade/post/e65e83c6-0984-4df9-9a7b-51ff8046a3a1/image.png" width="600" height ="400" />

**시간복잡도는?**
    
정렬의 시간복잡도는 일반적으로 숫자의 비교 횟수로 나타낸다. 입력이 **N**개 주어졌다고 가정하자. 분할 부분에서는 각 층(내려가면서 1, 2, 3...k층)마다 함수 호출은 $2^k$번 일어난다. 즉 1+2+4+...$2^k$ = $2N-1$ → $O(N)$의 시간복잡도를 가진다. 

병합 파트를 보자. 이번에는 각 층(내려가면서 1, 2, 3..k층)마다 숫자 비교횟수를 보면 결국 각 층마다 N번 비교 연산이 일어난다. 예를 들어 1층을 보면 `({27, 38}, {3, 43}, {9, 82}, {10})`이 있는데, 결국 모든 숫자를 한번씩 들여다봐야 되기에(비교), 그 횟수는 입력 크기에 비례한다. 즉, 그리고 층의 갯수는 N = $2^k$로 표현될때의 $k$개이다. 즉 병합 과정에서의 시간복잡도는 $O(Nk)$. 이때 $k$는 $log_2N$이므로 최종적으로 $O(NlogN)$이다.

> 결론: 병합정렬의 시간복잡도는 $O(NlogN)$이다.

**공간복잡도는?**

병합 정렬은 병합 과정에서 생기는 부분 정렬된 배열들을 저장해 나가는 별도의 배열이 필요하기 때문에 $O(N)$이다.



**동작 코드:**

```C++
    void merge_sort(int start, int end) // 분할 함수
    {
        if(end == start+1) // 배열 길이가 1이면 탈출
            return; 
        int mid = (start+end)/2; // 배열을 이등분하기 위한 중간 인덱스 설정
        merge_sort(start, mid); // 왼쪽 배열 나누기
        merge_sort(mid, end); // 오른쪽 배열 나누기 
        merge(start, end); // start부터 end까지 정렬
    }
```

* 분할 과정은 이렇다.
    - `mid`인덱스를 설정하여 이등분할 지점을 고른다. 그 후 왼쪽 시작 `start` 인덱스 부터 `mid`, `mid`부터 오른쪽 끝 `end`까지의 2개로 나누어 재귀적으로 함수를 호출한다. (주의, 실제로 배열이 나뉜건 아니고, 함수 호출을 통해 그때그때 배열이 관념적으로 나뉘었다고 생각). 그러다가 하나의 숫자만 남을때까지 나누면 `return`하여 `merge`함수를 통해 정렬 및 합병을 시작한다. 


```C++
    void merge(int start, int end)
    {
        int mid = (start+end)/2;
        int lidx = start; // 왼쪽 배열의 시작 인덱스
        int ridx = mid; // 오른쪽 배열의 시작 인덱스
        for(int i = start; i < end; i++)
        {
            if(lidx == mid) tmp[i] = arr[ridx++]; // 1
            else if(ridx == end) tmp[i] = arr[lidx++]; // 2
            else if(arr[lidx] <= arr[ridx]) tmp[i] = arr[lidx++]; // 3
            else tmp[i] = arr[ridx++]; // 4
        }
        for(int i = st; i < en; i++) arr[i] = tmp[i]; 
    }
```

* 합병 과정은 이렇다. 
    - 시작 index가 `start`, 끝 index가 `end`인 배열을 가지고 합병을 시작한다. `mid`는 아까 `merge_sort`함수에서 명시적으로 나누어놨던 그 지점을 가져오기 위해 있는 변수이다. `lidx`와 `ridx`는 왼쪽 배열과 오른쪽 배열의 시작 index이다.

    - 반복문을 살펴보자. `arr`배열은 정렬할 원래 배열, `tmp`는 병합을 하며 저장해 나갈 배열이다. 
        1. **왼쪽 배열의 끝까지 탐색했을때는 저절로 오른쪽 배열의 원소를 넣고 인덱스를 증가시켜라**이다. 이 말은, 왼쪽 배열의 모든 원소가 현재 오른쪽 배열의 `arr[ridx]`보다 작았다는 뜻이된다. 
        2. **반대로 오른쪽 배열의 끝까지 탐색했을때는 저절로 왼쪽 배열의 원소를 집어넣고 인덱스를 증가**이다. 이 경우는 1번의 정반대이다.
        3. **왼쪽 배열과 오른쪽 배열 현 인덱스 원소끼리 비교하여 왼쪽이 작거나 같으면 왼쪽 원소를 넣고 인덱스 증가**이다. 이 줄로 인해서 **안정 정렬(stable sort)** 특성을 가지게 된다. 안정 정렬이란, 동일한 특성이라면 그 순서 원래대로 그대로 가져간다는 의미이다. 값이 같아도 원래 순서대로 왼쪽 인덱스의 값을 넣기에 성립된다. 
        4. 3번의 반대일 경우 **오른쪽 배열 현 인덱스 원소를 집어놓고 인덱스 증가**이다.  

    - 그 후 원래 배열 `arr`에 `tmp`를 복사한다. <br><br>  

## 2) 퀵 정렬(Quick sort)
***
### 퀵 정렬:

* 입력이 2개의 부분문제로 분할된다. 부분문제의 크기는 일정하지 않다. 그 이유는 `pivot`이라는 녀석때문이다.  

* n개의 숫자가 주어졌다고 하자. n/2개씩 2개의 부분문제로 분할하고, base condition에 도달시에는 전체가 다 정렬이 되어있다. 그 이유는 퀵 정렬은 **정복**을 먼저 하고 그 후에 **분할**을 해 나가기 때문이다. 

* 동작 방식은 이렇다. `pivot`이라는 하나의 원소를 정해 `pivot`보다 작은 원소들은 `pivot`의 왼쪽으로, 큰 원소들은 오른쪽으로 보낸다. (이때, 순서는 상관없다. 그저 방금 말한 조건만 만족하면 된다.) 그럼 `pivot`을 기준으로 왼쪽 오른쪽에 배열이 생길것이다. ~~(`pivot`이 최대, 최소 값이 아닌 이상)~~ 그 각각의 배열에서 재귀적으로 새로운 `pivot`을 설정하고 이 과정을 되풀이 하다보면 결국 숫자들이 자기 자리를 찾아가면서 전체 정렬이 될것이다. 

<img src = "https://t1.daumcdn.net/cfile/tistory/271D2B3354545F7A13" width="400" height ="400" />

**시간복잡도는?**
    
입력이 N인 배열이 주어졌다고 하자. 퀵 정렬은 아까 말했듯이 정복을 먼저한다. 즉, `pivot`을 옳은 위치로 보내는 행위를 말한다. 정복 부분에서 각 층(내려가면서 1, 2, 3...k층)에서 `pivot`을 옳은 위치로 보내려면 결국 N개의 숫자를 모두 확인해야한다. 즉 `pivot`을 잘 설정해서 정확히 배열을 이등분 해나가는 과정을 반복하면 병합 정렬과 같은 $O(NlogN)$의 시간복잡도를 가진다. 

<img src = "https://www.baeldung.com/wp-content/uploads/sites/4/2020/08/Capture.png" width="600" height ="400" />

하지만 주의할점이 있다. 바로 `pivot`을 어떻게 정하냐인데, 만약 오름차순으로 이미 정렬된 배열이 입력으로 주어졌다고 하자. 그러면 `pivot`을 만약 첫번째 원소로 잡을 경우 1의 옳은 자리는 원래 자리 그대로다. 그 다음에 1의 오른쪽에만 배열이 남아있기에 과정을 반복한다. 이러다가 보면 결국 하나의 층에서 하나의 원소만을 배제시키는 것이다. 

결국 이 경우의 시간복잡도는 $N+(N-1)+(N-2)+...+1 = N(N+1)/2 → O(N^2)$이다!!!

> 결론: 퀵 정렬의 시간복잡도는 평균적으로 $O(NlogN)$이지만, 최악의 경우 $O(n^2)$이 될 수 있으니 `pivot`을 잘 고르자.


**공간복잡도는?**

퀵 정렬은 따로 새로운 배열을 생성하는게 아닌 원래 기존 배열에서의 원소의 자리를 바꿔나가기 때문에 추가 메모리는 필요 없다. 그저 평균 함수 호출의 수가 $log(N)$ 정도라고 한다.

**동작 코드:**

```C++
    void quick_sort(int start, int end) 
    { 
        if(end <= start+1) return; 
        int pivot = arr[start]; 
        int l = st+1; // 왼쪽 끝 포인터 
        int r = en-1; // 오른쪽 끝 포인터
        while(1)
        {
            while(l <= r && arr[l] <= pivot) l++;
            while(l <= r && arr[r] >= pivot) r--;
            if(l > r) break; 
            swap(arr[l], arr[r]);
        }
        swap(arr[st], arr[r]);
        quick_sort(st, r);
        quick_sort(r+1, en);
    }
```

* 과정은 이렇다.
    - `base condition`은 배열의 크기가 1이 되었을때이고, `pivot`은 가장 왼쪽 인덱스의 원소라고 가정한다. (어차피 어떤 최적화된 `pivot`을 골라 맨 왼쪽으로 보내는것과 과정은 같다) `l`과 `r`은 각각 원소들의 자리를 바꾸기 위한 포인터이다. `l`은 `pivot`보다 큰 값을 찾을때까지 오른쪽으로 움직이고(찾으면 멈춤), `r`은 작은 값을 찾을때까지 왼쪽으로 움직인다(동일). 그러다가 `l`과 `r`의 값이 정해지면 그 인덱스끼리의 값을 바꾼다. 큰 값이 왼쪽에 있고 작은 값이 오른쪽에 있는게 말이 안되지 않는가? 그래서 바꾸는것이다. 이러다보면 `l`의 왼쪽에는 항상 `pivot`보다 작은 원소들이, `r`의 오른쪽에는 항상 `pivot`보다 큰 원소들이 자리잡게 된다. 

    - 그러다가 `l`과 `r`이 교차하면 그때 `pivot`과 `r`인덱스의 원소를 교환한다. 이후 `pivot`왼쪽과 오른쪽 배열에 대해 각각 과정을 반복한다.

## 3) 선택 문제(Selection)
***
* 하..







