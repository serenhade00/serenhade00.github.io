---
layout: post
title: Chapter 1. Divide & Conquer
date: 2022-03-21 15:50
 
---

## 분할 정복 알고리즘(Divide and Conquer)이란?
***

> ~~**???: 그냥 말 그대로 문제를 분할해서 정복하는거 아닌가?**~~


**맞다.** 

<span style ="font-size:10px">~~이게 맞는다고?~~</span>

사실 알고리즘의 이름만을 보고 뭔지 대충 감이 잡히는게 있고 그렇지 않은 것도 있다. **분할 정복**의 경우는 아마 대부분 전자에 속할 듯 싶다. 

### **분할 정복(Divide and Conquer) :**


 <p align = "center"><img src = "https://cdn.kastatic.org/ka-perseus-images/db9d172fc33b90e905c1213b8cce660c228bb99c.png" width="600" height ="400" /></p>

* <mark>*정의:*</mark> 
    * 어렵고 복잡한 문제를 비교적 쉬운 간단한 문제들로 **쪼개서(Divide)** 그 문제들을 각개 **정복(Conquer)** 해나가는 것.


* <mark>*구조:*</mark>
    * 분할(Divide): 
        - 문제를 더 이상 <span style ="color:#F15F5F">분할할 수 없을때</span>까지 <span style="color:skyblue">동일한 유형</span>의 **부분문제(subproblem)** 들로 나눔. 


        - <span style ="color:#F15F5F">분할할 수 없을때</span>란, 더이상 답을 분할하지 않고 곧장 풀 수 있는 충분히 *"쉬운"* 문제를 마주쳤을때를 말한다. 이런 문제를 `"Base case"`라고 말한다. 


        - <span style = "color:skyblue">"동일한 유형"</span>이라는 점에도 주목해야한다. 분할 정복은 같은 성질(형태)를 가진 부분문제로 쪼개고 그 문제들을 다시 합치기에 스스로를 참조하고 호출하는 **재귀(recursion)** 기법이 사용된다. 


    * 정복(Conquer): 
        - 분할 과정이 끝난 후 마주친 `Base case` 문제들을 푼다. (가장 작은 단위의 하위 문제)


    * 병합(Merge): 
        - 하위 문제들의 정복 결과(답), 즉 **부분해(解)** 들을 합쳐나가면서 원래 문제에 대한 결과를 도출한다.


* <mark>조건 및 장점:</mark>
    * 분할 정복을 적용하려면 문제를 둘 이상의 부분 문제로 나누는 자연스러운 방법이 있어야 하며, 비슷한 맥락에서 부분 문제의 답을 조합하여 원래 문제의 답을 계산하는 효율적인 방법이 있어야 한다.

        ex) 주어진 수들을 오름차순으로 정렬 - [의사코드](https://namu.wiki/w/%EC%9D%98%EC%82%AC%EC%BD%94%EB%93%9C)로 표현

        ```
        오름차순_정렬(숫자 배열 k, 배열 크기 n)
        {
            while(n > 1)
                입력받은 배열을 반으로 계속 쪼갬
            if(n <= 1)
                탈출;
            쪼개진 배열 2개를 비교하며 정렬해 새로운 배열 생성 
            ...
            최종적으로 전부 정렬된 배열 return.
        }
        ```

    <p align = "center"> ↑ 오름차순 정렬 의사코드 ↑ </p> 


    * 재귀 형태를 이용하기에 당연히 각 부분 문제마다 **탈출 조건(base condition)** 이 존재해야한다. 

    * 장점: 문제를 쪼개서 해결함으로써 어려운 문제를 푸는데 시간 단축 및 정확한 답을 구할 수 있다.

* <mark>단점 및 한계:</mark>
    * 함수를 재귀적으로 호출한다는 점에서 호출 횟수가 커질 수 있고, 데이터를 보관하며 진행되기에 과도한 메모리가 사용될 가능성도 있다. 
    * 가장 치명적인것은 분할 과정에서 풀기 *"쉬운"* 문제까지 분할한다고 했는데, 과연 그 **기준**이 무엇이냐이다. 이 *"쉬운"* 문제를 정의하는 것이 오히려 [애매하고 어려운 파트](https://namu.wiki/w/%EC%95%84%EC%9D%B4%EB%9F%AC%EB%8B%88)다.

## 예시 1) 합병 정렬(Merge sort)
***







