<!doctype html>
<html>
<head>
<meta charset="utf-8">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/4.0.0/github-markdown.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release/build/styles/default.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">
<link rel="stylesheet" href="file:///c:\Users\seong\.vscode\extensions\goessner.mdmath-2.7.4\themes\default\style.css">

</head>
<body class="markdown-body">

<h2 dir="auto" id="%EB%B6%84%ED%95%A0-%EC%A0%95%EB%B3%B5-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98divide-and-conquer%EC%9D%B4%EB%9E%80">분할 정복 알고리즘(Divide and Conquer)이란?</h2>
<hr dir="auto">
<blockquote dir="auto">
<p dir="auto"><s><strong>???: 그냥 말 그대로 문제를 분할해서 정복하는거 아닌가?</strong></s></p>
</blockquote>
<p dir="auto"><strong>맞다.</strong></p>
<p dir="auto"><span style ="font-size:10px"><s>이게 맞는다고?</s></span></p>
<p dir="auto">사실 알고리즘의 이름만을 보고 뭔지 대충 감이 잡히는게 있고 그렇지 않은 것도 있다. <strong>분할 정복</strong>의 경우는 아마 대부분 전자에 속할 듯 싶다.</p>
<h3 dir="auto" id="%EB%B6%84%ED%95%A0-%EC%A0%95%EB%B3%B5divide-and-conquer"><strong>분할 정복(Divide and Conquer) :</strong></h3>
<div  dir="auto" ></div>
<img src = "https://cdn.kastatic.org/ka-perseus-images/db9d172fc33b90e905c1213b8cce660c228bb99c.png" width="600" height ="400" />
<ul dir="auto">
<li dir="auto">
<p dir="auto"><mark>정의:</mark></p>
<ul dir="auto">
<li dir="auto">어렵고 복잡한 문제를 비교적 쉬운 간단한 문제들로 <strong>쪼개서(Divide)</strong> 그 문제들을 각개 <strong>정복(Conquer)</strong> 해나가는 것.</li>
</ul>
</li>
<li dir="auto">
<p dir="auto"><mark>구조:</mark></p>
<ul dir="auto">
<li dir="auto">
<p dir="auto">분할(Divide):</p>
<ul dir="auto">
<li dir="auto">
<p dir="auto">문제를 더 이상 <span style ="color:#F15F5F">분할할 수 없을때</span>까지 <span style="color:skyblue">동일한 유형</span>의 <strong>부분문제(subproblem)</strong> 들로 나눔.</p>
</li>
<li dir="auto">
<p dir="auto"><span style ="color:#F15F5F">분할할 수 없을때</span>란, 더이상 답을 분할하지 않고 곧장 풀 수 있는 충분히 <em>&quot;쉬운&quot;</em> 문제를 마주쳤을때를 말한다. 이런 문제를 <code>&quot;Base case&quot;</code>라고 말한다.</p>
</li>
<li dir="auto">
<p dir="auto"><span style = "color:skyblue">&quot;동일한 유형&quot;</span>이라는 점에도 주목해야한다. 분할 정복은 같은 성질(형태)를 가진 부분문제로 쪼개고 그 문제들을 다시 합치기에 스스로를 참조하고 호출하는 <strong>재귀(recursion)</strong> 기법이 사용된다.</p>
</li>
</ul>
</li>
<li dir="auto">
<p dir="auto">정복(Conquer):</p>
<ul dir="auto">
<li dir="auto">분할 과정이 끝난 후 마주친 <code>Base case</code> 문제들을 푼다. (가장 작은 단위의 하위 문제)</li>
</ul>
</li>
<li dir="auto">
<p dir="auto">병합(Merge):</p>
<ul dir="auto">
<li dir="auto">하위 문제들의 정복 결과(답), 즉 <strong>부분해(解)</strong> 들을 합쳐나가면서 원래 문제에 대한 결과를 도출한다.</li>
</ul>
</li>
</ul>
</li>
<li dir="auto">
<p dir="auto"><mark>조건 및 장점:</mark></p>
<ul dir="auto">
<li dir="auto">
<p dir="auto">분할 정복을 적용하려면 문제를 둘 이상의 부분 문제로 나누는 자연스러운 방법이 있어야 하며, 비슷한 맥락에서 부분 문제의 답을 조합하여 원래 문제의 답을 계산하는 효율적인 방법이 있어야 한다.</p>
<p dir="auto">ex) 주어진 수들을 오름차순으로 정렬 - <a href="https://namu.wiki/w/%EC%9D%98%EC%82%AC%EC%BD%94%EB%93%9C">의사코드</a>로 표현</p>
<pre><code dir="auto"><code><div>오름차순_정렬(숫자 배열 k, 배열 크기 n)
{
    while(n &gt; 1)
        입력받은 배열을 반으로 계속 쪼갬
    if(n &lt;= 1)
        탈출;
    쪼개진 배열 2개를 비교하며 정렬해 새로운 배열 생성 
    ...
    최종적으로 전부 정렬된 배열 return.
}
</div></code></code></pre>
</li>
</ul>
<div  dir="auto" ></div>
  <p align = "center"> ↑ 오름차순 정렬 의사코드 ↑ </p> 
<ul dir="auto">
<li dir="auto">
<p dir="auto">재귀 형태를 이용하기에 당연히 각 부분 문제마다 <strong>탈출 조건(base condition)</strong> 이 존재해야한다.</p>
</li>
<li dir="auto">
<p dir="auto">장점: 문제를 쪼개서 해결함으로써 어려운 문제를 푸는데 시간 단축 및 정확한 답을 구할 수 있다.</p>
</li>
</ul>
</li>
<li dir="auto">
<p dir="auto"><mark>단점 및 한계:</mark></p>
<ul dir="auto">
<li dir="auto">함수를 재귀적으로 호출한다는 점에서 호출 횟수가 커질 수 있고, 데이터를 보관하며 진행되기에 과도한 메모리가 사용될 가능성도 있다.</li>
<li dir="auto">가장 치명적인것은 분할 과정에서 풀기 <em>&quot;쉬운&quot;</em> 문제까지 분할한다고 했는데, 과연 그 <strong>기준</strong>이 무엇이냐이다. 이 <em>&quot;쉬운&quot;</em> 문제를 정의하는 것이 오히려 <a href="https://namu.wiki/w/%EC%95%84%EC%9D%B4%EB%9F%AC%EB%8B%88">애매하고 어려운 파트</a>다.</li>
</ul>
</li>
</ul>
<h2 dir="auto" id="1-%EB%B3%91%ED%95%A9%ED%95%A9%EB%B3%91-%EC%A0%95%EB%A0%ACmerge-sort">1) 병합/합병 정렬(Merge sort)</h2>
<hr dir="auto">
<h3 dir="auto" id="%EC%A0%95%EB%A0%ACsorting">정렬(Sorting):</h3>
<ul dir="auto">
<li dir="auto">
<p dir="auto">정렬: 항목들을 체계적으로 정리하는 과정, 즉 어떤 <strong>기준</strong>을 가지고 그에 맞게 배치하는것.</p>
</li>
<li dir="auto">
<p dir="auto">어떤 방식으로 정렬할지는 물론 상황에 따라 다르지만 보통 숫자들이 주어졌을때는 <strong>오름차순</strong>으로, 문자열이 주어졌을때는 <strong>사전순</strong>으로 정렬하는 등의 일반적인 정렬들을 생각해보자.</p>
</li>
<li dir="auto">
<p dir="auto">선택, 삽입, 버블 등의 정렬은 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></eq>의 시간복잡도를 가지는 대표적인 정렬 알고리즘이다. 하지만 이번에 알아볼 병합 정렬은 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq>의 시간 복잡도를 가진다.</p>
</li>
</ul>
<h3 dir="auto" id="%EB%B3%91%ED%95%A9-%EC%A0%95%EB%A0%AC">병합 정렬:</h3>
<ul dir="auto">
<li dir="auto">
<p dir="auto">입력이 2개의 부분문제로 분할된다. 부분문제의 크기는 1/2로 감소하고, 개수는 2배로 늘어나는 분할 정복 알고리즘이다.</p>
</li>
<li dir="auto">
<p dir="auto">n개의 숫자가 주어졌다고 하자. n/2개씩 2개의 부분문제로 분할하고, base condition에 도달시 2개의 부분문제를 정렬시키며 합병하여 정렬(정복)한다. 즉, <strong>합병 과정</strong>이 <strong>정복 과정</strong>인 셈이다.</p>
</li>
</ul>
<div  dir="auto" ></div>
<img src = "https://media.vlpt.us/images/devjade/post/e65e83c6-0984-4df9-9a7b-51ff8046a3a1/image.png" width="600" height ="400" />
<p dir="auto"><strong>시간복잡도는?</strong></p>
<p dir="auto">정렬의 시간복잡도는 일반적으로 숫자의 비교 횟수로 나타낸다. 입력이 <strong>N</strong>개 주어졌다고 가정하자. 분할 부분에서는 각 층(내려가면서 1, 2, 3...k층)마다 함수 호출은 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span></eq>번 일어난다. 즉 1+2+4+...<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span></eq> = <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>N</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2N-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></eq> → <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></eq>의 시간복잡도를 가진다.</p>
<p dir="auto">병합 파트를 보자. 이번에는 각 층(내려가면서 1, 2, 3..k층)마다 숫자 비교횟수를 보면 결국 각 층마다 N번 비교 연산이 일어난다. 예를 들어 1층을 보면 <code>({27, 38}, {3, 43}, {9, 82}, {10})</code>이 있는데, 결국 모든 숫자를 한번씩 들여다봐야 되기에(비교), 그 횟수는 입력 크기에 비례한다. 즉, 그리고 층의 갯수는 N = <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span></eq>로 표현될때의 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span></eq>개이다. 즉 병합 과정에서의 시간복잡도는 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(Nk)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></eq>. 이때 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span></eq>는 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><msub><mi>g</mi><mn>2</mn></msub><mi>N</mi></mrow><annotation encoding="application/x-tex">log_2N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></eq>이므로 최종적으로 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(NlogN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">Nl</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></eq>이다.</p>
<blockquote dir="auto">
<p dir="auto">결론: 병합정렬의 시간복잡도는 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(NlogN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">Nl</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></eq>이다.</p>
</blockquote>
<p dir="auto"><strong>공간복잡도는?</strong></p>
<p dir="auto">병합 정렬은 병합 과정에서 생기는 부분 정렬된 배열들을 저장해 나가는 별도의 배열이 필요하기 때문에 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></eq>이다.</p>
<p dir="auto"><strong>동작 코드:</strong></p>
<pre><code class="code-line language-C++" dir="auto"><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> <span class="hljs-comment">// 분할 함수</span>
</span>{
  	<span class="hljs-keyword">if</span>(end == start+<span class="hljs-number">1</span>) <span class="hljs-comment">// 배열 길이가 1이면 탈출</span>
		<span class="hljs-keyword">return</span>; 
  	<span class="hljs-keyword">int</span> mid = (start+end)/<span class="hljs-number">2</span>; <span class="hljs-comment">// 배열을 이등분하기 위한 중간 인덱스 설정</span>
	merge_sort(start, mid); <span class="hljs-comment">// 왼쪽 배열 나누기</span>
  	merge_sort(mid, end); <span class="hljs-comment">// 오른쪽 배열 나누기 </span>
 	merge(start, end); <span class="hljs-comment">// start부터 end까지 정렬</span>
}
</div></code></pre>
<ul dir="auto">
<li dir="auto">분할 과정은 이렇다.
<ul dir="auto">
<li dir="auto"><code>mid</code>인덱스를 설정하여 이등분할 지점을 고른다. 그 후 왼쪽 시작 <code>start</code> 인덱스 부터 <code>mid</code>, <code>mid</code>부터 오른쪽 끝 <code>end</code>까지의 2개로 나누어 재귀적으로 함수를 호출한다. (주의, 실제로 배열이 나뉜건 아니고, 함수 호출을 통해 그때그때 배열이 관념적으로 나뉘었다고 생각). 그러다가 하나의 숫자만 남을때까지 나누면 <code>return</code>하여 <code>merge</code>함수를 통해 정렬 및 합병을 시작한다.</li>
</ul>
</li>
</ul>
<pre><code class="code-line language-C++" dir="auto"><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span>
</span>{
  	<span class="hljs-keyword">int</span> mid = (start+end)/<span class="hljs-number">2</span>;
  	<span class="hljs-keyword">int</span> lidx = start; <span class="hljs-comment">// 왼쪽 배열의 시작 인덱스</span>
  	<span class="hljs-keyword">int</span> ridx = mid; <span class="hljs-comment">// 오른쪽 배열의 시작 인덱스</span>
  	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = start; i &lt; end; i++)
    {
		<span class="hljs-keyword">if</span>(lidx == mid) tmp[i] = arr[ridx++]; <span class="hljs-comment">// 1</span>
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ridx == end) tmp[i] = arr[lidx++]; <span class="hljs-comment">// 2</span>
		<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(arr[lidx] &lt;= arr[ridx]) tmp[i] = arr[lidx++]; <span class="hljs-comment">// 3</span>
    	<span class="hljs-keyword">else</span> tmp[i] = arr[ridx++]; <span class="hljs-comment">// 4</span>
  	}
  	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = st; i &lt; en; i++) arr[i] = tmp[i]; 
}
</div></code></pre>
<ul dir="auto">
<li dir="auto">합병 과정은 이렇다.
<ul dir="auto">
<li dir="auto">
<p dir="auto">시작 index가 <code>start</code>, 끝 index가 <code>end</code>인 배열을 가지고 합병을 시작한다. <code>mid</code>는 아까 <code>merge_sort</code>함수에서 명시적으로 나누어놨던 그 지점을 가져오기 위해 있는 변수이다. <code>lidx</code>와 <code>ridx</code>는 왼쪽 배열과 오른쪽 배열의 시작 index이다.</p>
</li>
<li dir="auto">
<p dir="auto">반복문을 살펴보자. <code>arr</code>배열은 정렬할 원래 배열, <code>tmp</code>는 병합을 하며 저장해 나갈 배열이다.</p>
<ol dir="auto">
<li dir="auto"><strong>왼쪽 배열의 끝까지 탐색했을때는 저절로 오른쪽 배열의 원소를 넣고 인덱스를 증가시켜라</strong>이다. 이 말은, 왼쪽 배열의 모든 원소가 현재 오른쪽 배열의 <code>arr[ridx]</code>보다 작았다는 뜻이된다.</li>
<li dir="auto"><strong>반대로 오른쪽 배열의 끝까지 탐색했을때는 저절로 왼쪽 배열의 원소를 집어넣고 인덱스를 증가</strong>이다. 이 경우는 1번의 정반대이다.</li>
<li dir="auto"><strong>왼쪽 배열과 오른쪽 배열 현 인덱스 원소끼리 비교하여 왼쪽이 작거나 같으면 왼쪽 원소를 넣고 인덱스 증가</strong>이다. 이 줄로 인해서 <strong>안정 정렬(stable sort)</strong> 특성을 가지게 된다. 안정 정렬이란, 동일한 특성이라면 그 순서 원래대로 그대로 가져간다는 의미이다. 값이 같아도 원래 순서대로 왼쪽 인덱스의 값을 넣기에 성립된다.</li>
<li dir="auto">3번의 반대일 경우 <strong>오른쪽 배열 현 인덱스 원소를 집어놓고 인덱스 증가</strong>이다.</li>
</ol>
</li>
<li dir="auto">
<p dir="auto">그 후 원래 배열 <code>arr</code>에 <code>tmp</code>를 복사한다. <br><br></p>
</li>
</ul>
</li>
</ul>
<h2 dir="auto" id="2-%ED%80%B5-%EC%A0%95%EB%A0%ACquick-sort">2) 퀵 정렬(Quick sort)</h2>
<hr dir="auto">
<h3 dir="auto" id="%ED%80%B5-%EC%A0%95%EB%A0%AC">퀵 정렬:</h3>
<ul dir="auto">
<li dir="auto">
<p dir="auto">입력이 2개의 부분문제로 분할된다. 부분문제의 크기는 일정하지 않다. 그 이유는 <code>pivot</code>이라는 녀석때문이다.</p>
</li>
<li dir="auto">
<p dir="auto">n개의 숫자가 주어졌다고 하자. n/2개씩 2개의 부분문제로 분할하고, base condition에 도달시에는 전체가 다 정렬이 되어있다. 그 이유는 퀵 정렬은 <strong>정복</strong>을 먼저 하고 그 후에 <strong>분할</strong>을 해 나가기 때문이다.</p>
</li>
<li dir="auto">
<p dir="auto">동작 방식은 이렇다. <code>pivot</code>이라는 하나의 원소를 정해 <code>pivot</code>보다 작은 원소들은 <code>pivot</code>의 왼쪽으로, 큰 원소들은 오른쪽으로 보낸다. (이때, 순서는 상관없다. 그저 방금 말한 조건만 만족하면 된다.) 그럼 <code>pivot</code>을 기준으로 왼쪽 오른쪽에 배열이 생길것이다. <s>(<code>pivot</code>이 최대, 최소 값이 아닌 이상)</s> 그 각각의 배열에서 재귀적으로 새로운 <code>pivot</code>을 설정하고 이 과정을 되풀이 하다보면 결국 숫자들이 자기 자리를 찾아가면서 전체 정렬이 될것이다.</p>
</li>
</ul>
<div  dir="auto" ></div>
<img src = "https://t1.daumcdn.net/cfile/tistory/271D2B3354545F7A13" width="400" height ="400" />
<p dir="auto"><strong>시간복잡도는?</strong></p>
<p dir="auto">입력이 N인 배열이 주어졌다고 하자. 퀵 정렬은 아까 말했듯이 정복을 먼저한다. 즉, <code>pivot</code>을 옳은 위치로 보내는 행위를 말한다. 정복 부분에서 각 층(내려가면서 1, 2, 3...k층)에서 <code>pivot</code>을 옳은 위치로 보내려면 결국 N개의 숫자를 모두 확인해야한다. 즉 <code>pivot</code>을 잘 설정해서 정확히 배열을 이등분 해나가는 과정을 반복하면 병합 정렬과 같은 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(NlogN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">Nl</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></eq>의 시간복잡도를 가진다.</p>
<div  dir="auto" ></div>
<img src = "https://www.baeldung.com/wp-content/uploads/sites/4/2020/08/Capture.png" width="600" height ="400" />
<p dir="auto">하지만 주의할점이 있다. 바로 <code>pivot</code>을 어떻게 정하냐인데, 만약 오름차순으로 이미 정렬된 배열이 입력으로 주어졌다고 하자. 그러면 <code>pivot</code>을 만약 첫번째 원소로 잡을 경우 1의 옳은 자리는 원래 자리 그대로다. 그 다음에 1의 오른쪽에만 배열이 남아있기에 과정을 반복한다. 이러다가 보면 결국 하나의 층에서 하나의 원소만을 배제시키는 것이다.</p>
<p dir="auto">결국 이 경우의 시간복잡도는 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo>+</mo><mo stretchy="false">(</mo><mi>N</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>+</mo><mo stretchy="false">(</mo><mi>N</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><mn>1</mn><mo>=</mo><mi>N</mi><mo stretchy="false">(</mo><mi>N</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mi mathvariant="normal">/</mi><mn>2</mn><mo>→</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>N</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N+(N-1)+(N-2)+...+1 = N(N+1)/2 → O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">...</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord">/2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></eq>이다!!!</p>
<blockquote dir="auto">
<p dir="auto">결론: 퀵 정렬의 시간복잡도는 평균적으로 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>N</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(NlogN)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">Nl</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></eq>이지만, 최악의 경우 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></eq>이 될 수 있으니 <code>pivot</code>을 잘 고르자.</p>
</blockquote>
<p dir="auto"><strong>공간복잡도는?</strong></p>
<p dir="auto">퀵 정렬은 따로 새로운 배열을 생성하는게 아닌 원래 기존 배열에서의 원소의 자리를 바꿔나가기 때문에 추가 메모리는 필요 없다. 그저 평균 함수 호출의 수가 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">log(N)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></eq> 정도라고 한다.</p>
<p dir="auto"><strong>동작 코드:</strong></p>
<pre><code class="code-line language-C++" dir="auto"><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> 
</span>{ 
	<span class="hljs-keyword">if</span>(end &lt;= start+<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>; 
	<span class="hljs-keyword">int</span> pivot = arr[start]; 
	<span class="hljs-keyword">int</span> l = st+<span class="hljs-number">1</span>; <span class="hljs-comment">// 왼쪽 끝 포인터 </span>
	<span class="hljs-keyword">int</span> r = en<span class="hljs-number">-1</span>; <span class="hljs-comment">// 오른쪽 끝 포인터</span>
	<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)
    {
		<span class="hljs-keyword">while</span>(l &lt;= r &amp;&amp; arr[l] &lt;= pivot) l++;
		<span class="hljs-keyword">while</span>(l &lt;= r &amp;&amp; arr[r] &gt;= pivot) r--;
		<span class="hljs-keyword">if</span>(l &gt; r) <span class="hljs-keyword">break</span>; 
		swap(arr[l], arr[r]);
	}
	swap(arr[st], arr[r]);
	quick_sort(st, r);
	quick_sort(r+<span class="hljs-number">1</span>, en);
}
</div></code></pre>
<ul dir="auto">
<li dir="auto">과정은 이렇다.
<ul dir="auto">
<li dir="auto">
<p dir="auto"><code>base condition</code>은 배열의 크기가 1이 되었을때이고, <code>pivot</code>은 가장 왼쪽 인덱스의 원소라고 가정한다. (어차피 어떤 최적화된 <code>pivot</code>을 골라 맨 왼쪽으로 보내는것과 과정은 같다) <code>l</code>과 <code>r</code>은 각각 원소들의 자리를 바꾸기 위한 포인터이다. <code>l</code>은 <code>pivot</code>보다 큰 값을 찾을때까지 오른쪽으로 움직이고(찾으면 멈춤), <code>r</code>은 작은 값을 찾을때까지 왼쪽으로 움직인다(동일). 그러다가 <code>l</code>과 <code>r</code>의 값이 정해지면 그 인덱스끼리의 값을 바꾼다. 큰 값이 왼쪽에 있고 작은 값이 오른쪽에 있는게 말이 안되지 않는가? 그래서 바꾸는것이다. 이러다보면 <code>l</code>의 왼쪽에는 항상 <code>pivot</code>보다 작은 원소들이, <code>r</code>의 오른쪽에는 항상 <code>pivot</code>보다 큰 원소들이 자리잡게 된다.</p>
</li>
<li dir="auto">
<p dir="auto">그러다가 <code>l</code>과 <code>r</code>이 교차하면 그때 <code>pivot</code>과 <code>r</code>인덱스의 원소를 교환한다. 이후 <code>pivot</code>왼쪽과 오른쪽 배열에 대해 각각 과정을 반복한다.</p>
</li>
</ul>
</li>
</ul>
<h2 dir="auto" id="3-%EC%84%A0%ED%83%9D-%EB%AC%B8%EC%A0%9Cselection">3) 선택 문제(Selection)</h2>
<hr dir="auto">

</body>
</html>