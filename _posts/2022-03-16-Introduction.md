---
layout: post
title: Introduction To Computer Algorithm
date: 2022-03-17 15:30

---

## 알고리즘(Algorithm)이란?
***  
  
* *일반적 정의* : 단순히 어떤 문제를 해결하기 위한 방법 또는 이론


* *프로그래밍적 정의* : 어떠한 **입력**이 주어졌을때 그것을 기반으로 원하는 결과(**출력**)를 얻어내기 위한 정형화된 단계 절차




    ![My Algorithm Radar Chart](https://github.com/serenhade00/serenhade00.github.io/blob/main/assets/algorithm.png?raw=true)


   <p align="center">↑ 알고리즘 종류 레이더 차트 ↑</p>
    




## 시간/공간복잡도(Time/Space Complexity)란?
***

### **알고리즘의 효율성**:


1. *시간 복잡도 (Time Complexity)*



   ![Time_Complex](https://miro.medium.com/max/712/1*xamVYkZsA1kzLy9kerwOEA.png)


`시간 복잡도`는 말 그대로 자료 또는 입력의 수(n)이 주어졌을 때 프로그램이 결과를 도출하는데 걸리는 연산의 수, 즉 소요 시간(f(n))을 말한다.

이를 `Big-O 표기법`으로 주로 나타낸다. 물론 `Big-Omega`나 `Big-Theta`같은 표기법도 존재하나 잘 사용되지 않는다.

* **Big-O 표기법**

    ![Time_Complex2](https://camo.githubusercontent.com/8f93ea2bedbae36f5d4652edeb200f8c592d35a1e6dd9406a8edeacadb1fa124/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f3438353731332f3534373231372f61313138623465382d633262622d313165322d393566612d6237613539313462626636652e706e67)

    * `f(n)`의 점근적 상한(asymptotic upper bound)을 나타낸다.
    * 어떤 식 `f(n)`이 있으면, 그 식의 최고 차항을 가져오면 된다.
   * ex) 
        
        ![equa1](https://github.com/serenhade00/serenhade00.github.io/blob/main/assets/equa1.png?raw=true)
    
      


    ~~`f : 내가 아무리 안 좋아도 쟤(g)보단 성능이 나쁘지 않다`~~

결국 아무리 맞는 출력을 내놓는 프로그램이더라도 이 시간복잡도가 너무 크다면 결코 **효율적인 프로그램**이라고 말할 수 없다. 

다양한 알고리즘들이 각각 어떤 시간복잡도를 갖는지는 나중 포스트에서 다루겠다.

2. *공간복잡도 (Space Complexity)*

`공간 복잡도`도 직관적으로 이해하면 쉽다. 프로그램 실행을 위해 결국 얼마만큼의 공간(**메모리**)가 필요하느냐, 이다.

앞서 언급한 `Big-O 표기법`을 똑같이 주로 사용한다. 하지만 여기 공간복잡도에 대한 명언을 한번 짚고 넘어가자.

> ~~??? : 공간복잡도는 그냥 메모리 추가만 하면 됩니다.~~ 

농담이다. 사실 그저 현실에서는 시간복잡도보다 중요성이 <span style ="font-size:10px">떨어진다</span>는 것을 말하기 위함이다. 

그 이유는 하드웨어&소프트웨어의 발달로 인해 슈퍼 컴퓨터 등의 개발 이후로는 공간에 대한 걱정은 비교적 사그라들었기 때문이다. 물론 메모리를 적게 쓸수록 좋은건 맞지만 알고리즘의 효율성에 대해서는 시간적인 측면을 고려하는 경향이 크다.

다만, **임베디드** 같은 한정된 하드웨어 환경에서는 공간복잡도가 중요해질 수 있다.




## Git 및 GitHub
***

Git: [리누스 토르발스](https://namu.wiki/w/%EB%A6%AC%EB%88%84%EC%8A%A4%20%ED%86%A0%EB%A5%B4%EB%B0%9C%EC%8A%A4, "리누스 토르발스 문서")가 개발한 분산형 버전 관리 시스템 (Version Control System).

### 어떨때 쓰는가?


어떤 프로젝트를 만들때, 과연 개발자 또는 프로그래머 **한 명**이 모든걸 다 수행할 수 있을까? 물론 가능할 수도 있으나, 그 효율성이나 수행 시간에서 분명히 나쁜 측면을 찾을 수 있을것이다. 

그래서 협업할 수 있는 공간(**Github**)을 만들어서 서로의 작업물을 점점 추가(**add**)하며, 기여(**commit**)하며, 버전을 계속 새롭게 밀어낸다(**push**).

~~물론 정확한 설명은 아니지만, 저런 의미라고 생각하면 쉽다~~

 저 단어들을 굳이 쓴 이유는 저것들이 바로 **GIT**의 주요한 **명령어들**이기 때문이다. 
 
 ### GIT 주요 명령어

 * `git init`
    * 원하는 경로에 Git 저장소를 만듬. (Initialize)
 * `git status`
    * 현재 Git 상태를 보게 해줌.   
    * <span style="background-color: lightyellow">이게 되게 편한게 본인이 어떤 변경사항을 만든다면 그걸 인식하고 직관적으로 현재 상태를 보여준다.</span> 

 * `git add`
    * Git에 올라가기 전에 원하는 파일들을 대기실(staging area)로 추가함
    * ex) git add . → `.`은 현재 디렉토리에 있는 모든 파일을 add 하겠다는것.
 * `git commit -m["message"]`
    * 수정된 사항들에 대한 기록을 남긴다.
    * 이 **commit**을 통해 버전의 차이가 생기며, 기록을 해놨기 때문에 다시 다운그레이드 등이 가능하다.
 * `git push `
    * **GITHUB**같은 저장소에 **commit**된 수정 소스들을 업로드함.

Github: 대표적인 무료 **Git** 저장소.

* 주요 내용은 다음과 같다.

| 출시일 | 본사 | 서비스 | 개발 언어 |
|------------|----------|----------|--------|
| 2008.02.08 | Microsoft | Git 호스팅, 버전 관리 | [Ruby](https://namu.wiki/w/Ruby) |

**마크다운** 언어를 기반으로 한 **Jekyll**을 이용해 본인의 **Github**계정에 블로그를 생성할 수 있다. [그곳](https://serenhade00.github.io/)이 [이곳](https://serenhade00.github.io/)이다(~~재귀~~). 

* 테마 설치도 가능하다. (**Chirpy Theme 사랑합니다 ♥**)

* 요즘은 기업에서 **포트폴리오**로 대놓고 GITHUB 주소를 달라고 하는 곳이 많다고 하다. 그 정도로 영향력이 있는 도구이다. 

## 결론&TMI
*** 

* 알고리즘에 대한 간략한 소개를 진행했다. 


* 시간/공간 복잡도에 대한 개념을 배웠다. (프로그램 짤 때 고려사항)


* **GIT** 명령어를 하도 쓰다보니 이제 좀 익숙해진것 같다 .~~아닌가?~~


* 이 `Chirpy` 테마는 `gh-pages` 라는 새로운 branch를 생성하여 그 branch를 연결하여 사용하는 다른 테마와는 조금 다른 적용 방식을 가지고 있었다. 그래서 테마 적용하는데만 오류가 떠서 몇시간을 잡아먹혔다.


<p align="center">그럼, 다음 수업에 돌아오겠습니다.</p>










