---
layout: post
title: Chapter 3. Dynamic Programming
date: 2022-07-05 19:46
math: true
---

## 📰 다이나믹 프로그래밍(Dynamic Programming) 알고리즘이란? 📰
***

> Dynamic?? 알고리즘이 역동적...?

**Dynamic Programming.** 줄여서 **DP**라고 부르는 이 알고리즘은 정말 정말 다양한 유형의 문제가 있다. 딱히 뭔가 역동적(Dynamic)하거나 어떤 새로운 Programming의 방식을 가져서 이름 붙여진 것은 아니다. 

이에 관한 내용은 ↓, TMI 로.

### **다이나믹 프로그래밍(DP):**

- <mark>정의:</mark> 
    - **동적 계획법**이라고도 불리며, 여러 개의 하위 문제를 풀어나가며(저장 o), 그 결과를 이용해 최종 답을 도출하는 알고리즘.

이렇게 보면 [Chapter 1. 분할 정복](https://serenhade00.github.io/posts/1st-Divide-and-Conquer/)과 어찌보면 비슷한 면이 있다. 하지만 DP만의 특징을 좀 더 살펴보자.

- 메모리를 조금 더 사용하면서 연산속도를 비약적으로 증가시킨다.
- Top-Down / Bottom-Up 방식으로 두 가지 방식으로 구분된다.

Top-Down / Bottom-Up 방식을 좀 더 자세히 살펴보자.

1. Memoization -> Top-Down 방식
    - 재귀를 이용하여 값을 위에서부터 아래로 계산하기 때문에 **하향식(top-down)** 방식. `cache`에 값 기록, 중복 계산을 방지.

    ```c++
    int fib(int n)
    {
        if (n == 0) 
            return 0;
        if (n == 1) 
            return 1;
    
        if (dp[n] != -1) 
            return dp[n];
    
        dp[n] = fib(n - 1) + fib(n - 2);
        return dp[n];
    }
    ```

    <img src = "https://github.com/serenhade00/serenhade00.github.io/blob/main/assets/dp/fib1.png?raw=true" width="500" height ="300" />
    <p align="center">▲ 피보나치 하향식 구현 ▲</p>

2. Tabulation -> Bottom-up 방식
    - 주로 반복문을 이용하여 값을 아래에서부터 위로 계산하기 때문에 **상향식(bottom-up)** 방식. 리스트에 값을 기록, 중복 계산을 방지.

```c++
int fib(int n)
{
    dp[0] = 0;
    dp[1] = 1;
    for (int i = 2; i <= n; i++)
        dp[i] = dp[i - 1] + dp[i - 2];
}
```

<p align="center">▲ 피보나치 상향식 구현 ▲</p>


- <mark>조건 및 장점:</mark> 
    
    DP 알고리즘이 적용되기 위해 2가지 조건이 성립해야한다.

    - **1. 최적 부분 구조(optimal substructure)**
        - 문제에 대한 최종 해결 방법은 부분 문제에 대한 최적 문제 해결 방법으로 구성된다. 즉 작은 부분 문제에 대한 답을 모아 큰 문제를 해결
    - **2. 중복되는 부분 문제(overlapping subproblems)**
        - DP는 기본적으로 문제를 나누고 그 문제의 결과 값을 재활용해서 전체 답을 구한다. 그래서 동일한 작은 문제들이 반복하여 나타나는 경우에 적용 가능 

    DP 적용 방식:
    
    1) **DP로 풀 수 있는 문제인지 확인**
        - 어느 알고리즘이든 이게 어떤 알고리즘인지 단번에 파악하는게 힘들다. 보통 특정 데이터 내 최대화 / 최소화 계산을 하거나 특정 조건 내 데이터를 세야 한다거나 확률 등의 계산의 경우 DP로 풀 수 있는 경우가 많다.

    2) **문제의 변수 파악**
        - DP는 현재 변수에 따라 현재 결과값을 찾고 그것을 저장하여 재사용한다. 즉, 문제 내 변수의 개수와 의미를 파악해야한다. 이것을 `state`를 결정한다고 한다.
        - 예를 들어, 피보나치 수열에서 n번째 피보나치 숫자를 구하는 것이므로 n이 변수가 된다. 그 변수가 얼마냐에 따라 결과값이 다르나 그 결과를 재사용한다.
    
    3) **변수 간 관계식 만들기(점화식)**
        - 변수마다의 결과값을 얻으면, 각 변수 결과값끼리에 대해 관계를 만들어야 `DP`의 의미를 부여할 수 있다. 그러한 관계식을 **점화식**이라고 부르며 반복/재귀를 통해 문제가 자동으로 해결되도록 구현한다.
        - ex) 피보나치 수열에서는 $f(n) = f(n-1) + f(n-2)$ 였다.
    
    4) **메모하기(memoization or tabulation)**
        - 변수 간 관계식까지 정상적으로 생성되었다면 변수의 값에 따른 결과를 저장해야 한다. 이 결과 값을 저장할 때는 보통 배열을 쓰며 변수의 개수에 따라 배열의 차원이 1~3차원 등 다양할 수 있다.

    5) **기저 상태 파악하기**
        - 여기까지 진행했으면, 가장 작은 문제의 상태를 알아야 한다. 일단 시작점을 정의해야 점화식을 통해 점점 값을 채워나갈 수 있기에 필요하다.

    6) **구현하기**
        - 위에서 언급했던 방식 중 채택하여 구현한다.

    장점: 
    -  적용 가능시, 모든 가능성을 고려해 구현하므로 항상 최적의 결과를 얻을 수 있다.
    - 메모리에 값을 저장하며 그 값을 재활용하므로 큰 문제를 빠른 속도로 해결할 수 있다.

- <mark>단점 및 한계:</mark> 
    - 다른 방법에 비해 많은 저장 공간을 요구한다.

## DP 예제
***
<br>

### 1) 1로 만들기 - BOJ 1463
> 문제: 정수 N에 사용할 수 있는 3가지 연산이 있다. 정수 N이 주어졌을 때, 연산을 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하자.

- **부가 정보 & 조건**
    - N이 3으로 나누어 떨어지면, 3으로 나눈다.
    - N이 2로 나누어 떨어지면, 2로 나눈다.
    - 1을 뺀다.

이 문제는 왜 DP인가? 왜냐면 모든 정수에 대해 일일이 연산을 계산할 필요가 없이, 하위 값들을 재활용하며 큰 정수까지도 최적해를 빠르게 구할 수 있기 때문이다.

**1) 테이블 정의**
> $D[i]$ = 숫자 $i$를 1로 만들기 위해 필요한 연산의 최소 횟수.

**2) 점화식 세우기**

어떤 숫자 $n$을 고려할 때, $D[n]$은 어떻게 구할 수 있을까? DP의 특성상 현재 보는 수의 하위값들을 다 알고있다고 가정하자. 연산의 종류에 따라서 총 3가지의 경우의 수가 있다.

ex) $n = 18$, $D[n]$ = ?

연산의 조건에 의해, 3으로 나누기, 2로 나누기, 1로 빼기가 모두 적용되므로,
    $D[18] = D[6] + 1, D[18] = D[9] + 1, D[17] + 1$와 같이 나타낼 수 있다. 이 중 최솟값이 $D[n]$의 정의에 부합한다.

즉 일반화시키면 $D[n] = min(D[n/3]+1, D[n/2]+1, D[n-1]+1)$이다.

**3) 초기값 설정**

$D[1] = 0$ 으로만 설정하면 나머지 정수에 대해서는 연산을 통해 해를 구할 수 있다.
왜냐하면 `1`밑으로는 내려갈 일이 없고, 숫자가 올라가면서 나중 상위 값 계산에 필요한 하위 값들을 채워나가기 때문이다.

- **접근법 및 구현:**
    - 전역 배열을 하나 선언한 후(자동적으로 모든값 0으로 초기화), 초기값 $D[1]=1$을 설정해준다. 
    - 단순한 반복문과 조건문으로, 모든 수는 일단 3번째 연산이 가능하므로(1 빼기) 설정한 후, 3과 2로 나눠지는 수 인지 체크하고 나눠지면 기존의 $D[i]$값과 비교하여 `min`값을 채택한다.
    - 테이블을 채워넣은 후 $D[n]$을 출력한다.

```c++
#include <bits/stdc++.h>

using namespace std;

int num[1000001];

int main(void)
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	
	int n;
	cin >> n;
	num[1] = 0;                                   // 초기값
	
	for(int i=2; i<=n; i++)
	{
		num[i] = num[i-1]+1;                      // 3번째 연산 적용
		if(i%2==0)
			num[i] = min(num[i/2]+1, num[i]);     // 2번째 연산 가능 여부 확인 및 적용
		if(i%3==0)
			num[i] = min(num[i/3]+1, num[i]);     // 1번째 연산 가능 여부 확인 및 적용
	}
	cout << num[n];
}
```

### 2) RGB거리 - BOJ 1149
> 문제: RGB거리에는 집이 N개 있다. 집은 빨강, 초록, 파랑 중 하나의 색으로 칠해야 한다. 각각의 집을 빨강, 초록, 파랑으로 칠하는 비용이 주어졌을 때, 아래 규칙을 만족하면서 모든 집을 칠하는 비용의 최솟값을 구해보자.

- **부가 정보 & 조건**
    - 1번 집의 색은 2번 집의 색과 같지 않아야 한다.
    - N번 집의 색은 N-1번 집의 색과 같지 않아야 한다.
    - i(2 ≤ i ≤ N-1)번 집의 색은 i-1번, i+1번 집의 색과 같지 않아야 한다.

이 문제는 접하면 `DP`가 아니라 `Greedy`가 아닌가? 라는 생각이 들 수 있다. 즉 N번째 집을 고려할 때, N-1번째 집과 색깔이 다른 두 집 중 최솟값을 계속 골라나가는 형태로 구현하면 되지않는가? 라는 의문이 든다. 

이에 대한 반례를 설명하겠다. 

<img src = "https://github.com/serenhade00/serenhade00.github.io/blob/main/assets/dp/rgb.jpg?raw=true" width="400" height ="300" />

여기서의 실제 최적해는 <span style ="color:#FF4000">26</span>+<span style ="color:#1266FF">57</span>+<span style ="color:#FF4000">13</span>으로 이어지는 '96'이다. 하지만 그리디한 방법으로 접근했을 때, 1번째 집에서 <span style ="color:#47C83E">3</span>(최솟값), 2번째 집은 빨강과 파랑만 가능하므로 <span style ="color:#FF4000">49</span>, 그 다음 초록과 파랑만 가능하므로 <span style ="color:#47C83E">89</span>. 즉 141이라는 해가 나오고, 이는 오답이다. 

**애초에 그리디로는 정해진 조건에 의해 탐색하기에, 모든 경로를 탐색할 수가 없기에, 최적해를 보장할 수 없다.** 즉, 내가 첫번째 집을 고른순간 이미 다음 집을 무엇을 고를지 정해지는 셈이고, 운이 좋으면 이 경로들 중 답이 있을수는 있지만 항상 보장하지는 않는다.

**1) 테이블 정의**
- $D[i][1]$ = $i$번째 집까지 칠할 때의 최소 비용, 단 $i$번째 집은 <span style ="color:#FF4000">빨강. 
- $D[i][2]$ = $i$번째 집까지 칠할 때의 최소 비용, 단 $i$번째 집은 <span style ="color:#47C83E">초록. 
- $D[i][3]$ = $i$번째 집까지 칠할 때의 최소 비용, 단 $i$번째 집은 <span style ="color:#1266FF">파랑. 

**2) 점화식 세우기**

DP는 문제 형태의 따라 테이블을 1차원, 2차원, 3차원 등으로 세우는데, 이 문제는 2차원 배열이 사용되었다. 문제 조건에 의해 바로 직전에 칠해진 집과는 동일한 색깔로 칠할 수 없다. 

ex) $D[i][1]$이 채워지려면, $D[i-1][2], D[i-1][3]$ 중 최솟값을 택한 후, $i$번째 집을 빨강으로 칠하는 값을 더하면 된다. 이를 초록과 파랑에도 적용하면 된다.


**3) 초기값 설정**

1번째 집을 각각의 색으로 칠하는 최소 비용은 입력으로 주어진 그 숫자 그대로이기 때문에 이 값들만 초기값으로 세팅해준다. 그 이후로는 가능한 경로들을 고려하며 값이 채워나가진다.

- **접근법 및 구현:**
    - 전역 배열을 하나 선언한 후(자동적으로 모든값 0으로 초기화), 초기값 $D[1][1], D[1][2], D[1][3]$을 설정해준다. 
    - $N$번째 집마다 특정 색깔로 칠하는 걸 고려할 땐 이전 집을 그 색깔이 아닌 색으로 칠했을때의 최솟값 선택 후 현재 색깔로 칠하는 값을 더하도록 구현한다.
    - 테이블을 채워넣은 후 $min(D[n][1], D[n][2], D[n][3])$을 출력한다.

```c++
#include <bits/stdc++.h>

using namespace std;

int house[1001][4];                                // 각 색깔로 칠하는 입력값
int sum[1001][4];                                  // DP 테이블

int main(void)
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	
	int n;
	cin >> n;
	for(int i=1; i<=n; i++)
	{
		for(int j=1; j<=3; j++)
		{
			cin >> house[i][j];                    
		}
	}
	for(int i=1; i<=3; i++)
	{
		sum[1][i] = house[1][i];                   // 1번째 집 초기값 세팅
	}
	for(int i=2; i<=n; i++)
	{
		sum[i][1] = min(sum[i-1][2], sum[i-1][3])+house[i][1];  // 빨강으로 칠하기
		sum[i][2] = min(sum[i-1][1], sum[i-1][3])+house[i][2];  // 초록으로 칠하기
		sum[i][3] = min(sum[i-1][1], sum[i-1][2])+house[i][3];  // 파랑으로 칠하기
	}
	cout << min(min(sum[n][1], sum[n][2]),sum[n][3]);
}
```

### 3) 평범한 배낭 - BOJ 12865
> 문제: 준서가 여행에 필요하다고 생각하는 N개의 물건이 있다. 각 물건은 무게 W와 가치 V를 가진다. 준서는 최대 K만큼의 무게만을 넣을 수 있는 배낭을 들고 다닌다. 준서가 최대한 즐거운 여행을 하기 위해 배낭에 넣을 수 있는 물건들의 가치의 최댓값을 알려주자.

- **부가 정보 & 조건**
    - 입력으로 주어지는 수는 모두 정수이다.

이 문제는 **0-1 Knapsack**이라고 불리는 DP의 대표적인 예이다. 즉 각각의 물건이 넣지 않거나(0), 물건을 넣는(1) 두개의 상태로 구분되기에 이렇게 이름이 붙여졌다.

<img src = "https://github.com/serenhade00/serenhade00.github.io/blob/main/assets/dp/knapsack.png?raw=true" width="400" height ="300" />

**1) 테이블 정의**
- $D[i][w]$ = $1$~$i$번째 물건까지 고려해, 임시 배낭 용량이 $w$일 때의 최대 가치
- 여기서 말하는 임시 배낭 용량이란, 원래 문제에서 원하는 답이 배낭의 용량이 C라고 할 때, 1부터 C까지 1씩 증가해나가며 그때그때의 현재 용량을 말한다.

**2) 점화식 세우기**

이중 반복문을 통해, 물건을 첫번째 물건부터 n번째 물건까지, 각각 1부터 C까지의 용량에 대해 값을 채워나간다. 

경우의 수 1) 만약 $W$<sub>$i$</sub>가 $W$를 초과하면, $D[i][w] = D[i-1][w]$
 - 왜냐하면 $i$번째 물건을 배낭에 담을 수 없기에, $i-1$번째 물건까지 고려했을 때와 동일하다.

경우의 수 2) 그렇지 않다면, $D[i][w]$ = $min(D[i-1][w]$, $D[i-1][w-w$<sub>$i$</sub>])이다.
- 1번에 해당되지 않는다면 $i$번째 물건을 담을 수 있는 상태이다. 그러나 현재 상태에서 담으면 배낭의 무게는 $w$+w<sub>$i$</sub>이 되어 기존 무게인 $w$를 초과해 모순이 발생한다. 따라서 $w$에서 w<sub>$i$</sub>를 빼주어 물건이 들어갈 공간을 마련한다. 그 상태에서 물건 $i$를 배낭에 넣는다고 생각하면 된다.

**3) 초기값 설정**

- $D[i][0]$ = 배낭의 용량이 0일때, 아무 물건도 담을 수 없으므로 0으로 초기화.
- $D[0][w]$ = 아무런 물건도 배낭에 담는걸 고려하지 않았을때, 0으로 초기화.

- **접근법 및 구현:**
    - 전역 배열을 하나 선언한 후, 초기값을 설정한다.
    - $i$번째 물건의 무게와 임시 배낭 용량을 확인하며 점화식 조건에 맞춰 값을 채운다.
    - 테이블을 채워넣은 후 $D[n][w]$을 출력한다.

```c++
#include <bits/stdc++.h>

using namespace std;

int bag[101][100001];                                 // DP 테이블
int thing[101][2];

int main(void)
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	
	int n, w;
	cin >> n >> w;
	for(int i=1; i<=n; i++)
		cin >> thing[i][0] >> thing[i][1];            // 무게, 가치 입력
	
	for(int i=1; i<=n; i++)
	{
		int weight = thing[i][0];                     // i번째 물건 무게
		int val = thing[i][1];                        // i번째 물건 가치
		for(int j=1; j<=w; j++)
		{
			if(weight > j)                            // 임시 용량 초과시
				bag[i][j] = bag[i-1][j];
			else
				bag[i][j] = max(bag[i-1][j], bag[i-1][j-weight]+val); 
		}
	}
	cout << bag[n][w];
}
```

### 4) 동전 1 - BOJ 2293
> 문제: n가지 종류의 동전이 있다. 각각의 동전이 나타내는 가치는 다르다. 이 동전을 적당히 사용해서, 그 가치의 합이 k원이 되도록 하고 싶다. 그 경우의 수를 구하시오. 

- **부가 정보 & 조건**
    - 각각의 동전은 몇 개라도 사용할 수 있다.
    - 사용한 동전의 구성이 같은데, 순서만 다른 것은 같은 경우이다.


**1) 테이블 정의**
- $D[i]$ = $i$원을 만드는 경우의 수 

**2) 점화식 세우기**

가장 값이 낮은 동전부터 하나씩 이용하여 만들 수 있는 값을 모두 고려한다. 

ex) 1, 2, 5원이 있다고 하자. 그리고 만들고 싶은 수는 10원이라고 하자. 1원으로만 만들 수 있는 경우의 수는 1-10까지의 수를 그 수만큼의 1원을 이용하여 만드는 것이므로 $D[1]$~$D[10]$이 1씩 증가한다. 

그 다음 2원으로 만들 수 있는 걸 보자. 일단 2원 하나만 써서 2원을 만들 수 있고, 3원은 1+2원, 4원은 2원+2원, 5원은 3+2원....즉, $j$라는 수를 만들기 위해 $D[j-2]$의 경우의 수만큼을 더해나가고 있다. 이는 나머지 동전에도 적용될 것이다. 

즉, $D[n]$의 경우의 수에 원하는 동전을 사용했을때, 그 동전의 값이 $v$라고 하면, $D[n+v] += D[n]$이 성립할 것이다. 

**3) 초기값 설정**

- 입력으로 주어지는 동전들을 한번씩 사용하여 바로 그 가치만큼을 바로 만들 수 있다. 이 때 주의해야할 점은 미리 반복문으로 각 동전의 인덱스에 해당하는 $D[i]$를 증가시켜놓으면 안된다.
- 그 이유는 이렇다. 만약 위의 예제에서 미리 값을 증가시켰다고 하자. 그러면 1원을 고려할 때 모든 인덱스에 대해 기본적으로 1씩 증가하고, 2원과 5원에 대해 초기값을 설정하므로 $D[2] = 2, D[5] = 2$가 된다. 이 때 $D[3]$을 고려할 때 $D[3] += D[3-1]$이므로 $D[3] = 2$가 된다. 2원을 고려할 때, $D[3] += D[3-2]$이므로 $D[3] = 3$이 된다. 하지만 실제로는 $3 = 1+2, 1+1+1$, 이렇게 2가지의 경우의 수가 다이다. 
- 왜 이런 결과가 나왔는가? 왜냐하면 각각 동전을 사용했을때만 고려하며 값을 증가해나가야 하는데 미리 초기화를 시켜놓으면 1원만을 고려하는 과정에서 이미 2원만을 사용한 경우의 수가 추가되어 $D[2]$가 1만큼 증가했기 때문에, 1만을 고려하는 과정에서 이미 $1+1+1, 2+1$의 경우의 수가 이미 만족되어 버린 것이다. 따라서 미리 초기화가 아닌 각 동전을 고려할때마다 그 동전의 인덱스만 1씩 증가시켜야한다. 

- **접근법 및 구현:**
    - 각 동전을 고려하며 현재 값 + 현재의 동전을 썼을 때의 값에 현재 값만큼 더해준다.
    - 테이블을 채워넣은 후 $D[n]$을 출력한다.

```c++
#include <bits/stdc++.h>

using namespace std;

int num[101];
int d[10001];
int main(void)
{
    int n, k;
    cin >> n >> k;
    for(int i=0; i<n; i++)
        cin >> num[i];
  
    for(int i=0; i<n; i++)
    {
    	if(num[i] > k)                     // 원하는 값 초과하면 더이상 고려 필요 x
    		continue;
    	d[num[i]]++;
        for(int j=num[i]+1; j<=k; j++)
        {
            d[j] += d[j-num[i]];           // 이 동전을 쓰기 전의 값만큼을 이 동전을 썼을 때의 값에 더해준다.
        }
    }
    cout << d[k];
}
```

## 결론 & TMI
***

* `DP`역시 그리디와 더불어 문제가 정말 많아 단골 문제로 자주 출제된다.
* 나는 `Bottom-up` 방식이 더 편한 것 같다. ~~재귀야 물러가라.~~
* 테이블 정의와 점화식을 얼마나 잘 찾느냐가 `DP`의 핵심이다.
* 원래는 `DP`를 이름붙인 `Richard Bellman`은 처음에 `Programming`이라는 단어 대신 `Planning`을 쓰려다가 마음에 들지 않아 바꿨다고 한다. `Dyanmic`이라는 단어도 딱히 의미 없이 그냥 ~~간지가 나서~~ 붙였다고 한다.

<br>
<p align="center">Copyrightⓒ. 2022. By Seonghwan Shin. </p>
<p align="center">All Rights Reserved.</p>
<p align="center">-The End-</p>