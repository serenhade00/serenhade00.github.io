---
layout: post
title: Chapter 3. Dynamic Programming
date: 2022-07-05 19:46
math: true
---

## 📰 다이나믹 프로그래밍(Dynamic Programming) 알고리즘이란? 📰
***

> Dynamic?? 알고리즘이 역동적...?

**Dynamic Programming.** 줄여서 **DP**라고 부르는 이 알고리즘은 정말 정말 다양한 유형의 문제가 있다. 딱히 뭔가 역동적(Dynamic)하거나 어떤 새로운 Programming의 방식을 가져서 이름 붙여진 것은 아니다. 

이에 관한 내용은 ↓, TMI 로.

### **다이나믹 프로그래밍(DP):**

- <mark>정의:</mark> 
    - **동적 계획법**이라고도 불리며, 여러 개의 하위 문제를 풀어나가며(저장 o), 그 결과를 이용해 최종 답을 도출하는 알고리즘.

이렇게 보면 [Chapter 1. 분할 정복](https://serenhade00.github.io/posts/1st-Divide-and-Conquer/)과 어찌보면 비슷한 면이 있다. 하지만 DP만의 특징을 좀 더 살펴보자.

- 메모리를 조금 더 사용하면서 연산속도를 비약적으로 증가시킨다.
- Top-Down / Bottom-Up 방식으로 두 가지 방식으로 구분된다.

Top-Down / Bottom-Up 방식을 좀 더 자세히 살펴보자.

1. Memoization -> Top-Down 방식
    - 재귀를 이용하여 값을 위에서부터 아래로 계산하기 때문에 **하향식(top-down)** 방식. `cache`에 값 기록, 중복 계산을 방지.

```c++
int fib(int n)
{
    if (n == 0) 
        return 0;
    if (n == 1) 
        return 1;
 
    if (dp[n] != -1) 
        return dp[n];
 
    dp[n] = fib(n - 1) + fib(n - 2);
    return dp[n];
}
```

<img src = "https://github.com/serenhade00/serenhade00.github.io/blob/main/assets/dp/fib1.png?raw=true" width="500" height ="300" />
<p align="center">▲ 피보나치 하향식 구현 ▲</p>

2. Tabulation -> Bottom-up 방식
    - 주로 반복문을 이용하여 값을 아래에서부터 위로 계산하기 때문에 **상향식(bottom-up)** 방식. 리스트에 값을 기록, 중복 계산을 방지.

```c++
int fib(int n)
{
    dp[0] = 0;
    dp[1] = 1;
    for (int i = 2; i <= n; i++)
        dp[i] = dp[i - 1] + dp[i - 2];
}
```

<p align="center">▲ 피보나치 상향식 구현 ▲</p>


- <mark>조건 및 장점:</mark> 
    
    DP 알고리즘이 적용되기 위해 2가지 조건이 성립해야한다.

    - **1. 최적 부분 구조(optimal substructure)**
        - 문제에 대한 최종 해결 방법은 부분 문제에 대한 최적 문제 해결 방법으로 구성된다. 즉 작은 부분 문제에 대한 답을 모아 큰 문제를 해결
    - **2. 중복되는 부분 문제(overlapping subproblems)**
        - DP는 기본적으로 문제를 나누고 그 문제의 결과 값을 재활용해서 전체 답을 구한다. 그래서 동일한 작은 문제들이 반복하여 나타나는 경우에 적용 가능 

    DP 적용 방식:
    1) DP로 풀 수 있는 문제인지 확인한다.
        - 어느 알고리즘이든 이게 어떤 알고리즘인지 단번에 파악하는게 힘들다. 보통 특정 데이터 내 최대화 / 최소화 계산을 하거나 특정 조건 내 데이터를 세야 한다거나 확률 등의 계산의 경우 DP로 풀 수 있는 경우가 많다.
    2) 문제의 변수 파악
        - DP는 현재 변수에 따라 현재 결과값을 찾고 그것을 저장하여 재사용한다. 즉, 문제 내 변수의 개수와 의미를 파악해야한다. 이것을 `state`를 결정한다고 한다.
        - 예를 들어, 피보나치 수열에서 n번째 피보나치 숫자를 구하는 것이므로 n이 변수가 된다. 그 변수가 얼마냐에 따라 결과값이 다르나 그 결과를 재사용한다.
    
    3) 변수 간 관계식 만들기(점화식)
        - 변수마다의 결과값을 얻으면, 각 변수 결과값끼리에 대해 관계를 만들어야 `DP`의 의미를 부여할 수 있다. 그러한 관계식을 **점화식**이라고 부르며 반복/재귀를 통해 문제가 자동으로 해결되도록 구현한다.
        - ex) 피보나치 수열에서는 f(n) = f(n-1) + f(n-2) 였다.
    
    4) 메모하기(memoization or tabulation)
        - 변수 간 관계식까지 정상적으로 생성되었다면 변수의 값에 따른 결과를 저장해야 한다. 이 결과 값을 저장할 때는 보통 배열을 쓰며 변수의 개수에 따라 배열의 차원이 1~3차원 등 다양할 수 있다.

    5) 기저 상태 파악하기
        - 여기까지 진행했으면, 가장 작은 문제의 상태를 알아야 한다. 일단 시작점을 정의해야 점화식을 통해 점점 값을 채워나갈 수 있기에 필요하다.
    6) 구현하기
        - 위에서 언급했던 방식 중 채택하여 구현한다.

    장점: 
    -




