---
layout: post
title: Chapter 2. Greedy
date: 2022-07-05 16:00
math: true
---

## 😋 그리디(Greedy) 알고리즘이란? 😋
***

> Greedy..? 탐욕적..? 뭔가 욕심을 부리는 알고리즘인가..

그렇다. **극한의 이득을 취해가며 문제를 풀어나가는 방식의 알고리즘**이다. 그래서 *Greedy*라고 불린다. 하지만, <u>모든 알고리즘들이 그렇듯 특정 상황에만 적용 가능하다.</u>

### **그리디(Greedy):**

- <mark>정의:</mark> 
    - 현 상태에서, **가장 최적인 답**을 **근시안적**으로 택하는 알고리즘.

![img1](https://github.com/serenhade00/serenhade00.github.io/blob/main/assets/greedy/example.png?raw=true)

여기서 말하는 **가장 최적인 답**의 예시를 들어보자.

> ex) 루트 노드에서 출발하여 가장 큰 수를 구하기

여기서 우리는 직관적으로 20이 정답인걸 알 수 있다. 그러나 *Greedy*한 접근방법에 의하면,
1. 첫번째 선택 과정에서 7과 8을 접해(현재 선택지들)이 중 가장 큰 수인 8을 고른다.
2. 8이 있는 경로로 내려가고, 다음 두번째 선택 과정에서 4와 6을 접해(현재 선택지들)이 중 가장 큰 수인 6을 최종해로 결정한다.

즉, 상황에 따라 가장 최적인 답의 형태는 바뀔 수 있고, 여기서는 현재 상황에서의 가장 큰 수를 골라나가는것이 최적해를 리턴하지 않으므로, *Greedy*가 적용될 수 없는 문제인 것이다.
- <mark>조건 및 장점:</mark> 
    
    그리디 알고리즘이 적용되기 위해 2가지 조건이 성립해야한다.
    - **1. 탐욕 선택 속성(greedy choice property)**
        - 앞의 선택이 이후에 선택에 영향을 주지 않아야한다. 즉 매 선택의 순간마다 그 상황에만 충실해 최적해를 골라 나가야한다. 앞의 선택이 이후에 선택에 영향을 주는 [DP](https://serenhade00.github.io/posts/3rd-DP/)와 차별화 되는 점이다.

    - **2. 최적 부분 구조(optimal substructure)**
        - 문제에 대한 최종 해결 방법은 부분 문제에 대한 최적 문제 해결 방법으로 구성된다. 즉, 문제에 대한 최종 해결법이 부분 문제에 대해서도 역시 해결법으로 적용된다는 의미이다. 

    이런 조건들을 만족하는 문제일 때, 그리디 알고리즘은 항상 최적해를 찾을 수 있다. 이런 형태의 문제들을 **매트로이드(matroid)** 라고 한다. 

    장점: 
    - 다른 알고리즘들에 비해 풀이법을 떠올리기 쉽다. 왜냐하면 이런 그리디한 풀이가 성립하려면 어떤 순서를 기준으로 값을 처리하는 경향이 다분하다. 따라서 **정렬**이라던가 **우선순위 큐**의 사용법만 알면 웬만한 문제는 풀이가 가능하다. 많은 알고리즘 중 가장 기본적이고 쉬운 형태라고도 한다.

- <mark>단점 및 한계:</mark> 
    - 순간마다 하는 선택은 지역적으로는 최적이지만, 그 선택들을 계속 누적하여 최종적(전역적)인 해답을 만들었다고 해서, 그것이 최적이라는 보장은 없다.
    - 특정 상황에만 성립하는 알고리즘으로, 적용할 수 있는지 여부를 먼저 판단해야한다.

## 1) 회의실 배정

    
    

