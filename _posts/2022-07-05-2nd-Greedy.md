---
layout: post
title: Chapter 2. Greedy
date: 2022-07-05 16:00
math: true
---

## 😋 그리디(Greedy) 알고리즘이란? 😋
***

> Greedy..? 탐욕적..? 뭔가 욕심을 부리는 알고리즘인가..

그렇다. **극한의 이득을 취해가며 문제를 풀어나가는 방식의 알고리즘**이다. 그래서 *Greedy*라고 불린다. 하지만, <u>모든 알고리즘들이 그렇듯 특정 상황에만 적용 가능하다.</u>

### **그리디(Greedy):**

- <mark>정의:</mark> 
    - 현 상태에서, **가장 최적인 답**을 **근시안적**으로 택하는 알고리즘.

![img1](https://github.com/serenhade00/serenhade00.github.io/blob/main/assets/greedy/example.png?raw=true)

여기서 말하는 **가장 최적인 답**의 예시를 들어보자.

> ex) 루트 노드에서 출발하여 가장 큰 수를 구하기

여기서 우리는 직관적으로 20이 정답인걸 알 수 있다. 그러나 *Greedy*한 접근방법에 의하면,
1. 첫번째 선택 과정에서 7과 8을 접해(현재 선택지들)이 중 가장 큰 수인 8을 고른다.
2. 8이 있는 경로로 내려가고, 다음 두번째 선택 과정에서 4와 6을 접해(현재 선택지들)이 중 가장 큰 수인 6을 최종해로 결정한다.

즉, 상황에 따라 가장 최적인 답의 형태는 바뀔 수 있고, 여기서는 현재 상황에서의 가장 큰 수를 골라나가는것이 최적해를 리턴하지 않으므로, *Greedy*가 적용될 수 없는 문제인 것이다.
- <mark>조건 및 장점:</mark> 
    
    그리디 알고리즘이 적용되기 위해 2가지 조건이 성립해야한다.
    - **1. 탐욕 선택 속성(greedy choice property)**
        - 앞의 선택이 이후에 선택에 영향을 주지 않아야한다. 즉 매 선택의 순간마다 그 상황에만 충실해 최적해를 골라 나가야한다. 앞의 선택이 이후에 선택에 영향을 주는 [DP](https://serenhade00.github.io/posts/3rd-DP/)와 차별화 되는 점이다.

    - **2. 최적 부분 구조(optimal substructure)**
        - 문제에 대한 최종 해결 방법은 부분 문제에 대한 최적 문제 해결 방법으로 구성된다. 즉, 문제에 대한 최종 해결법이 부분 문제에 대해서도 역시 해결법으로 적용된다는 의미이다. 

    이런 조건들을 만족하는 문제일 때, 그리디 알고리즘은 항상 최적해를 찾을 수 있다. 이런 형태의 문제들을 **매트로이드(matroid)** 라고 한다. 

    장점: 
    - 다른 알고리즘들에 비해 풀이법을 떠올리기 쉽다. 왜냐하면 이런 그리디한 풀이가 성립하려면 어떤 순서를 기준으로 값을 처리하는 경향이 다분하다. 따라서 **정렬**이라던가 **우선순위 큐**의 사용법만 알면 웬만한 문제는 풀이가 가능하다. 많은 알고리즘 중 가장 기본적이고 쉬운 형태라고도 한다.

- <mark>단점 및 한계:</mark> 
    - 순간마다 하는 선택은 지역적으로는 최적이지만, 그 선택들을 계속 누적하여 최종적(전역적)인 해답을 만들었다고 해서, 그것이 최적이라는 보장은 없다.
    - 특정 상황에만 성립하는 알고리즘으로, 적용할 수 있는지 여부를 먼저 판단해야한다.

## 그리디 예제
***
<br>

### 1) 회의실 배정 - BOJ 1931
> 문제: 한 개의 회의실이 있다. 각 회의가 겹치지 않게 하면서 회의실을 사용할 수 있는 회의의 최대 개수를 찾아보자. 

- **부가 정보 & 조건**
    - 단, 회의는 한번 시작하면 중간에 중단될 수 없다.
    - 한 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있다.
    - 회의의 시작시간과 끝나는 시간이 같을 수도 있다. 이 경우는 시작하자마자 끝나는 것.

이 문제는 왜 그리디일까? 일단 그리디가 적용될 수 있는 문제인지는 아직 모르겠지만, 그리디한 풀이를 일단 떠올려보자. 그러면 다음과 같은 방법이 떠오른다.

> **회의의 끝나는 시간이 가장 빠른순으로 회의를 배정한다.** 

과연 이 방법으로 최적해를 찾아낼 수 있을까? 만약 이 명제에 대한 반례를 찾아낼 수 있다면, 이 방법은 틀렸으며 그리디한 풀이가 적용될 수 없는 문제라고 판단할 수 있다. 

ex) 회의 시간 배정 예시

<img src = "https://github.com/serenhade00/serenhade00.github.io/blob/main/assets/greedy/office.jpg?raw=true" width="500" height ="300" />

$t$는 현재의 시간이다. 검은 줄 하나가 회의 하나를 나타내며, 왼쪽 끝은 시작 지점, 오른쪽 끝은 종료 지점이다. 만약 위의 명제에 대한 반례가 있다고 가정하자. 그렇다면, **"더 늦게 끝나는 회의를 골랐을 때 더 많은 회의를 배정할 수 있는 경우의 수가 있다"** 가 성립해야한다. 

그리디의 풀이대로라면 더 일찍 끝나는 <span style ="color:#2E2EFE">B</span>를 다음 회의로 배정하겠지만, 더 늦게 끝나는 <span style ="color:#FF4000">A</span>를 골라보자. 이때, <span style ="color:#FF4000">A</span>를 고른 이후에 어떤 경우의 수가 오든, <span style ="color:#2E2EFE">B</span>를 골랐을때에도 최소한 동일한 수의 회의를 배정할 수 있다. 그러므로, 원래 명제의 역은 틀렸다. 따라서 원래 명제가 옳으므로, 그리디한 풀이가 적용될 수 있는 문제임을 증명했다. 

- **접근법 및 구현:**
    - 끝나는 시간이 가장 빠른 회의 순으로 정렬하되, 시작하는 시간도 가장 빠른 순으로 정렬한다. 그 이유는 시작하자마자 끝나는 회의의 존재때문이다. 예를 들어 `(3, 5)`와 `(5, 5)`의 회의가 있을때, 만약 전 회의가 3초에 끝났다면 `(3, 5)`를 배정하는게 이득이고, 만약 5초에 끝났다면 `(5, 5)`를 배정하여 시작하자마자 끝나는 회의를 하나 더 집어넣을 수 있다. 
    - `C++`에서 `pair`클래스는 `first`, `second`순으로 자동 오름차순 정렬을 해주는 기능이 있다. `first`에 종료 시간, `second`에 시작 시간을 입력받아 정렬하면 자동으로 종료 시간이 빠른 순으로, 종료 시간이 같다면 시작 시간이 빠른 순으로 정렬해줄 것이다. 
    - 정렬 후, 앞에서부터 살펴보며 회의의 시작 시간이 현재 회의의 종료 시간보다 크거나 같은 회의를 배정하면 된다. (이미 원하는 순서로 정렬해놨기에, 시작 시간만 체크하면서 바로 바로 다음 회의를 배정하면 됨)

```c++
#include <bits/stdc++.h>

using namespace std;

pair<int, int> a[100001];

int main(void)
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	
	int n;
	int cnt = 1, off = 0;
	cin >> n;
	for(int i=0; i<n; i++)
		cin >> a[i].second >> a[i].first;  // 종료 시간, 시작 시간순 저장
	sort(a, a+n);                          // 정렬
	
	off = a[0].first;                      // 최초 회의 배정
	for(int i=1; i<n; i++)
	{
		if(a[i].second >= off)             // 시작 시간이 현재 회의 종료보다 빠르면 그 회의 배정
		{
			off = a[i].first;              // 현재 회의 갱신
			count++;                       // 회의 수 갱신
		}
	}
	cout << cnt;
}
```

### 2) A와 B - BOJ 12904
> 문제: 두 문자열 S와 T가 주어졌을 때, S를 T로 바꾸는 게임이다. 문자열을 바꿀 때는 다음과 같은 두 가지 연산만 가능하다. S를 T로 만들 수 있는지 없는지 알아내라.

- **부가 정보 & 조건**
    * 문자열의 뒤에 A를 추가한다. 
    * 문자열을 뒤집고 뒤에 B를 추가한다.

이 문제는 왜 그리디일까? 처음 봤을때는 단순한 문자열 문제로 보인다. 하지만 이 문제의 문자열의 길이는 최대 1000이다. 현재 문자열에 대해 두가지 연산을 할 수 있으므로, 한 단계마다 경우의 수는 $2^n$로 기하급수적으로 증가한다. 첫 문자열 S에서 2개의 문자열, 그 2개의 문자열에 각각 또 연산을 하면 4개의 문자열...이런식으로 말이다. 이러다가 즉 최악의 경우 2<sup>1000</sup>개까지의 연산을 누적해야하므로, 당연히 시간초과가 난다. 

이 문제가 사실 그리디인 이유는 이렇다. 

<img src = "https://github.com/serenhade00/serenhade00.github.io/blob/main/assets/greedy/b-a.jpg?raw=true" width="500" height ="300" />

역으로 T->S로 가는 연산을 생각해보자. 만약 T의 마지막 글자가 'A'라면, 무조건 그 전 문자열에서 첫번째 연산이 이루어진 것이다. (두번째 연산은 B를 맨 뒤 B를 추가하므로 x) 만약 T의 마지막 글자가 'B'라면, 그 전 문자열에서 두번째 연산이 이루어진다. 즉, 결국 무궁무진한 경우의 수 중 T를 만드는 단 하나의 경우의 수를 찾는것처럼 보이지만 **S에서 T에 다다르는 경우의 수는 그 경로가 정해져있다.** 

이게 핵심이다. 따라서 T에서 S로 역연산을 실행해서 S가 나오면 경우의 수가 존재하는 것이다. 즉, 거쳐가야만 하는 연산의 경로가 정해져있기에, 현재 문자열의 끝 글자에 따라 역연산을 진행해나가면 되기에, **그리디**한 문제이다.

- **접근법 및 구현:**
    - T에서 S로 가는 연산은, 원래 연산의 반대이므로 첫번째 연산은 맨 뒤에서 A를 제거하는 연산, 두번째 연산은 맨 뒤에서 B를 제거한 후 문자열을 거꾸로 뒤집는 연산으로 변환한다. 
    - T의 길이-S의 길이만큼만 연산을 하고, 문자열의 길이가 동일해질때 S와 비교하여 동일하면 경우의 수 존재, 다르면 경우의 수 존재 x.
    - `string` 클래스에서 마지막 문자를 제거하는 `pop_back()`, 문자열을 뒤집어주는 `reverse()`함수를 이용.

```c++
#include <bits/stdc++.h>

using namespace std;

int main(void)
{
    string s1, s2, ans;
    cin >> s1 >> s2;
    ans = s2;
    int len = s2.size()-s1.size();            // 연산 횟수
    for(int i=0; i<len; i++)
    {
        if(s2.back() == 'A')                  // A로 끝나면, 1번 역연산
            s2.pop_back();
        else                                  // B로 끝나면, 2번 역연산
        {
            s2.pop_back();                    
            reverse(s2.begin(), s2.end());
        }
    }
    if(!s2.compare(s1))                       // S와 비교
        cout << 1;
    else
        cout << 0;
}
```

### 3) 카드 정렬하기 - BOJ 1715

> 문제: 정렬된 두 묶음의 숫자 카드가 있다고 하자. 각 묶음의 카드의 수를 A, B라 하면 두 묶음을 합쳐서 하나로 만드는 데에는 A+B 번의 비교를 해야 한다. ex) 20장의 묶음과 30장의 묶음을 합치려면 50번의 비교가 필요하다. N개의 숫자 카드 묶음의 각각의 크기가 주어질 때, 최소한 몇 번의 비교가 필요한지를 구하는 프로그램을 작성하시오.

- **부가 정보 & 조건**
    * 두 묶음씩 골라 서로 합쳐나간다면, 고르는 순서에 따라서 비교 횟수가 매우 달라진다.
    * 예를 들어 10, 20, 40장의 묶음이 있을 때, 오름차순으로 고르면 <span style ="color:#FF4000">(10+20)</span>+(<span style ="color:#FF4000">30</span>+40)=100의 비교가 필요 <-> 10-40-20순으로 고르면 <span style ="color:#FF4000">(10+40)</span>+(<span style ="color:#FF4000">50</span>+20)=120의 비교가 필요.

이 문제는 비교적 그리디임이 직관적으로 바로 보일 것이다. 왜냐하면 비교 횟수는 두 묶음의 카드 수의 합인데, 이를 최소로 만들어 나가라면 현재 가장 카드 수가 작은 묶음 2개씩을 골라나가면 되기 때문이다. 이 문제는 따로 수학적인 증명이 필요없을 것이다. 바로 구현해보자. 

- **접근법 및 구현:**
    - 이 문제는 접근법은 떠올리기 비교적 쉬운 문제이나, 구현에 살짝 애를 먹을 수 있다. 
    - 후보 1) `vector`나 배열에서 `min()`함수를 두번 사용해 최솟값을 두번 찾고, 그 더한 값을 집어넣는다. 이 방법의 한계는 찾은 최솟값 두 개를 제거하려면 결국 앞에서 뒤까지 탐색하며 $O(n)$에 매번 제거를 해줘야한다. `min()`함수와 만들어진 합을 집어넣는 과정이 $O(1)$인건 좋으나, 전 묶음을 다 보려면 $O(n)$에 매 과정마다 제거하는 과정이 $O(n)$이므로 $O(n^2)$의 시간복잡도를 가져 시간초과이다.
    - 후보 2) 매 루프마다 `sort()`를 통해 정렬하며 앞에서 두번째 까지의 원소를 찾아 더한 후, 그 값을 집어넣는다. 이 방법은 최솟값 찾기, 최솟값 제거, 더한 값 삽입까지는 각각 $O(1)$에 이뤄낼 수 있으나, 매 루프마다 정렬을 해야하므로 가장 빠른 정렬 방법을 사용하더라도 $O(N log N)$이므로 역시 전과 동일하게 전 묶음을 다 보는 과정을 곱하면 $O(N^2 log N)$이 될 것이다.
    - <mark>후보 3)</mark> 우선순위 큐를 사용해 최소 원소 두개를 리턴한 후, `pop`하며, 그 더한 값을 `push`한다. 이는 각각 $O(1)$, $O(log N)$, $O(log N)$에 이루어진다. 즉 하나의 루프마다 $O(log N)이면 처리가 가능하므로, 최종적인 시간 복잡도는 $O(N log N)$에 처리가 가능하다.

**여기서 잠깐, 우선순위 큐와 그 STL:**

우선순위 큐란?
- `pop`을 할 때, 가장 먼저 들어온 원소가 나오는 대신(*원래 큐의 정의*) cd우선순위가 가장 높은 원소가 나오는 큐(우선순위의 종류는 달라질 수 있음)

STL:

| 함수 형태 | 동작 방식 | 시간복잡도 | 매개 변수 |
|---|---|---|---|
| `push()` | 값을 우선순위 큐에 삽입한다. | $O(log N)$ | 집어넣을 값 |
| `pop()` | 값을 우선순위 큐에서 제거한다. | $O(log N)$ | 제거할 값 |
| `top()` | 값을 우선순위 큐에서 리턴한다. (제거는 x) | $O(1)$ | 리턴할 값|

<img src = "https://github.com/serenhade00/serenhade00.github.io/blob/main/assets/greedy/heap.png?raw=true" width="500" height ="300" />

따라서, 여기서는 부모 노드가 자식 노드보다 항상 작은 최소 힙(heap)을 사용한 우선순위 큐를 사용하면, 금방 구현할 수 있다.

```c++
#include <bits/stdc++.h>

using namespace std;

int main(void)
{
	ios::sync_with_stdio(0);
	cin.tie(0);
	
	int n;
	int sum = 0, tmp = 0;
	cin >> n;
    if(n==1)                                           
    {
        cout << 0;
        return 0;
    }
	
	priority_queue<int, vector<int>, greater<int>> q;   // 최소 힙
	
	for(int i=0; i<n; i++)
	{
		int x; 
		cin >> x;
		q.push(x);
	}
	while(!q.empty())                                   // 큐에 원소가 있는 동안
	{
		for(int i=0; i<2; i++)                          // 최솟값 2개 더하고 pop
		{
			tmp += q.top();
			q.pop();
		}
		sum += tmp;                                     // 연산 값 누적
		if(q.empty())                                   
			break;
		q.push(tmp);                                    // tmp값 push
		tmp = 0;
	}
	cout << sum;
}
```

## 결론 & TMI
***
* 그리디는 DP(Dynamic Programming)와 양대산맥으로 가장 기본적이며 많은 유형의 문제를 가지고 있는 알고리즘이다. 
* 적용할 수 있는 상황이 제한되어있다.
* 주로 정렬, 우선순위 큐, 와 같이 특정 순서나 우선순위가 사용되는 기법과 자주 적용된다.
* 보통 문제가 그리디임을 바로 캐치해내기 힘들기에, 이것저것 해보다가 안되면 혹시 그리디인가? 라는 생각을 해보자. ~~(이왜그)~~
* ~~현재 내 백준 알고리즘 태그 순위 1등이다~~

<br>
<p align="center">Copyrightⓒ. 2022. By Seonghwan Shin. </p>
<p align="center">All Rights Reserved.</p>
<p align="center">-The End-</p>

